<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Shelter Prime">


    <meta name="subtitle" content="Lock and load.">


    <meta name="description" content="OI 加油! Shelter Prime 加油!">



<title>DP 练习记录 | Shelter Prime&#39;s Blog</title>



    <link rel="icon" href="/favicon.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="/mathjax/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 6.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                //document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                //document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Napoleon_Bonaparte&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Napoleon_Bonaparte&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">DP 练习记录</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Shelter Prime</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十月 18, 2022&nbsp;&nbsp;9:22:47</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/OI/">OI</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="P4310"><a href="#P4310" class="headerlink" title="P4310"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4310">P4310</a></h2><p>类似最长上升子序列，我们可以推出以下式子：</p>
<p>$\text{dp} = \max{dp_j + 1}, j &lt; i$</p>
<p>并且 a[i] &amp; a[j] 不为 0。（为什么不写进 $\LaTeX$ 呢？因为新博文的并不支持 &amp; 这个东西，一用就挂。）</p>
<p>考虑位运算的特性，每一位并不相关，那么我们可以让 $dp_i$ 表示 二进制下第 i 位为  1 的最大值，这样我们每次找到一个数直接给他二进制拆分，先更新当前最大值，然后拿最大值去更新  dp 数组，这样时间复杂度就变成了 $\mathcal{O}(n \log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j) <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) tmp = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j) <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) dp[j] = <span class="built_in">max</span>(dp[j], tmp);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="P2184"><a href="#P2184" class="headerlink" title="P2184"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1284">P2184</a></h2><p>不是很方便知道具体的边长，那么我们就转换思路为看能否圈出 a，b，c 长度的三条边。</p>
<p>则 $dp_{a, b, c}$ 表示能否围成 a，b，c 三条边。</p>
<p>一算空间爆掉了，想办法优化。</p>
<p>因为周长已知，那么我们只需要知道两条边即可推出第三边，那么我们就可以优化成：</p>
<p>$$dp_{i, j, k}$$ 表示第 i 个点，长度为 j，k 两条边能否围成。</p>
<p>经过研究可以发现，我们可以直接原地滚动数组，第一维直接省略掉，转化为。</p>
<p>考虑状态转移方程：</p>
<ol>
<li>如果我们将当前边放到 j 处，则我们需要通过 $dp_{j - a_i, k}$ 推过来。</li>
<li>如果我们将当前边放到 k 处，则我们需要通过 $dp_{j, k - a_i}$ 推过来。</li>
<li>如果我们将当前边放到第三条边，我们只需要 $dp_{j, k}$ 推过来。</li>
</ol>
<p>那么状态转移方程为：$dp_{i, j} |= (dp_{i - a_k, j}, dp_{i, j - a_k})$</p>
<p>现在我们已知了可以到达的边，去枚举这些边，然后判断是否可以凑出这三条边，再看能否围成三角形，最后统计答案输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum &gt;&gt; <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = sum &gt;&gt; <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= a[i]) dp[j][k] |= dp[j - a[i]][k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= a[i]) dp[j][k] |= dp[j][k - a[i]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sum; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">is_ok</span>(i, j, sum - i - j)) <span class="keyword">continue</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">calc</span>(i, j, sum - i - j));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1133"><a href="#P1133" class="headerlink" title="P1133"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1133">P1133</a></h2><p>首先分析题意，可以得出线性 DP。</p>
<p>一维肯定不够，我们需要知道上一个子问题状态选择了哪一棵树，因此加上一维，这样最初的状态就变成了：$dp_{i, \ 0/1/2}$，表示到了第 i 个位置，放高度为 10，高度为 1，高度为 2 的树的最大收益。</p>
<p>坑人的是，我们依旧无法转移，因为我们没办法知道这个树是比左右都低还是比左右都高。</p>
<p>那就，再塞进去一维！</p>
<p>现在变成了：$dp_{i, \ 0/1/2, \ 0/1}$ 表示第 i 个位置，放高度为 10，高度为 1，高度为 2 的树，并且当前的树比左右两边都矮或比左右两边都高的最大收益。</p>
<p>现在好像可以做了，我们推一下状态转移方程：</p>
<p>$$dp_{i, 0, 0} = \max{dp_{i-1, 1, 1}, dp_{i - 1, 2, 1}} + a[i]$$</p>
<p>$$dp_{i, 1, 0} = dp_{i - 1, 2, 1} +b[i]$$</p>
<p>$$dp_{i, 1, 1} = dp_{i - 1, 0, 0} + b[i]$$</p>
<p>$$dp_{i, 2, 1} = \max{dp_{i - 1, 0, 0},\  dp_{i - 1, 1, 0}} + c[i]$$</p>
<p>考虑一下初始化，直接设成 0 就可以了。</p>
<p>最后答案枚举最后一颗树的种类状态即可。</p>
<p>来一波操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]) + a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + b[i];</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + b[i];</span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[n][i][j]);</span><br></pre></td></tr></table></figure>

<p>然后我们壮烈地牺牲了 30 pts。</p>
<p>分析一下原因我们发现，我们未能正确处理好最后一棵树和第一颗树的关系，因此导致了 WA。</p>
<p>那我们就不得不换种思路：先枚举第一颗树的状态，然后以这个状态为基础去更新接下来的位置，然后在更新的途中就把最大值取了。</p>
<p>现在我们过了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">                dp[<span class="number">1</span>][i][k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">1</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">2</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]) + a[i];</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + b[i];</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + b[i];</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + c[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i) ans = <span class="built_in">max</span>(ans, dp[n][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &gt; j; --i) ans = <span class="built_in">max</span>(ans, dp[n][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="POJ1742"><a href="#POJ1742" class="headerlink" title="POJ1742"></a><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1742">POJ1742</a></h2><p>一眼多重背包，上去先来个朴素的解法，成功过了样例，然后 TLE 了。</p>
<h3 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h3><p>首先可以看出这是个多重背包，那么我们就可以将每一个物品分出来，按照 01 背包那么折腾，这样时间复杂度是 $\mathcal{O(m\sum_{i=1}^{n}c_i)}$ ，毫无疑问地去世。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = m; k &gt;= a[i]; --k)</span><br><span class="line">                dp[k] |= dp[k - a[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += dp[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制拆分"><a href="#二进制拆分" class="headerlink" title="二进制拆分"></a>二进制拆分</h3><p>既然朴素的没辙，那我们就玩一下之前学过的二进制拆分来优化一下这个东西。</p>
<p>但是这样的时间复杂度是 $\mathcal{O(m\sum_{i=1}^{n}\log{c_i})}$，但是数据实在是太强大了，依旧超时。</p>
<p>不过至少能优化掉一大片吧……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                b[++tot] = j * a[i];</span><br><span class="line">                c[i] -= j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c[i]) b[++tot] = a[i] * c[i];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= b[i]; --j)</span><br><span class="line">                    dp[j] |= dp[j - b[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            ans += dp[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>注意啊，这里只是在怎么决策的时候贪心了一下，整体上还是 DP。</p>
<p>我们发现一个奇妙的性质：这题我们只要可行性就好了，不需要最优性。</p>
<p>既然如此，如果前 i 种硬币能拼成 j，只有两种可能：</p>
<ol>
<li>j 早就被拼出来了。</li>
<li>用一下第 i 种硬币拼成 j。</li>
</ol>
<p>很明显，我们能用 1 解决的就不用 2 解决。这样我们设一个 $used_j$ 表示让 $dp_j$ 在 i 阶段时为 true 至少需要多少种第 i 枚硬币，能用 1 就用1，并且将 $used_j$ 设成 0，这时候不需要第 i 种硬币来解决问题。</p>
<p>否则，考虑用当前硬币解决问题，退回到上一个状态，看一下那个状态耗费的第 i 种硬币数是否比给定的数量少，如果少的话并且那个状态已经拼出来了，我们就转移，否则就……</p>
<p>终于，时间复杂度被我们弄成了 $\mathcal{O(nm)}$，总算是过了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) used[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!dp[j] &amp;&amp; dp[j - a[i]] &amp;&amp; used[j - a[i]] &lt; c[i])</span><br><span class="line">                dp[j] = <span class="literal">true</span>, used[j] = used[j - a[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += dp[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P1006"><a href="#P1006" class="headerlink" title="P1006"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1006">P1006</a></h2><p>线性 DP，我们先来分析一下状态，很明显，我们可以将当前路径的长度作为状态。</p>
<p>我们依然需要知道当前的末尾位置，因此我们还要想方设法地折腾出表示两个末尾位置的方法。</p>
<p>经过仔细的分析我们发现：我们走过的路径 $i$，和两个末尾节点的坐标 $x1, y1$， $x2, y2$ 的关系是这样的：</p>
<p>$i + 2 = x1 + y1 = x2 + y2$</p>
<p>注意，初始点的位置并不算进经过的路径中。</p>
<p>那么我们现在就可以用三个状态推知剩下的两个状态了：</p>
<p>$$y1 = i + 2 - x1, y2 = i + 2 - x2$$</p>
<p>这样一来我们就可以通过枚举三个维度，从而得到另外两个维度的信息。</p>
<p>设：$dp_{i, x1, x2}$ 表示路径长度为 i，一条路径的末节点的横坐标为 x1，另一条为 x2。</p>
<p>考虑 $x1 = x2$ 的转移：</p>
<ol>
<li><p>如果当前 $x1 = x2$，那么向下走的时候会走到同一个节点上，那么我们就只能取一次值：$dp_{i + 1, x1 + 1, x2 + 1} = \max{dp_{i + 1, x1 + 1, x2 + 1}, dp_{i, x1, x2} + a_{x1, y1 + 1}}$</p>
</li>
<li><p>如果当前 $x1 = x2$，那么向右走的时候也会走到同一个节点上，同理：$dp_{i + 1, x1, x2} = \max{dp_{i + 1, x1, x2}, dp_{i, x1, x2} + a_{x1 + 1, y1}}$</p>
</li>
</ol>
<p>当 $x1 = x2 + 1$ 或 $x2 =x1 + 1$</p>
<ol>
<li><p>这时候向下走就要考虑一下了，因为一个节点会走到曾经取走过的节点上，这时候我们就要考虑一下向下更新的问题了。如果 $x1 + 1 = x2$，说明 x1 在 x2 的斜右上边，这时候我们先让 x1 走到与 x2 相同的位置上，此时我们只能够取到 $a_{x1 + 1, y1}$ 的位置上的价值（如果看不懂可以自行画图理解）。</p>
</li>
<li><p>第二种情况同理呦。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x1 = <span class="number">1</span>; x1 &lt;= n &amp;&amp; x1 &lt;= i + <span class="number">1</span>; ++x1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x2 = <span class="number">1</span>; x2 &lt;= n &amp;&amp; x2 &lt;= i + <span class="number">1</span>; ++x2) &#123;</span><br><span class="line">                <span class="keyword">int</span> y1 = i - x1 + <span class="number">2</span>, y2 = i - x2 + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x1 == x2) &#123; <span class="comment">// 当两端点的横坐标在同一水平位置上</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>]); <span class="comment">// 横着走只能更新一次</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1]); <span class="comment">// 竖着往下走也只能更新一次0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][x1][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>] + a[x2][y2 + <span class="number">1</span>]); <span class="comment">// 横着走两个都加</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1] + a[x2 + <span class="number">1</span>][y2]); <span class="comment">// 竖着走也无妨</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(x1 + <span class="number">1</span> == x2) dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1]); <span class="comment">// 要是竖着走到了同一个地方，只更新一下就可以</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1] + a[x2][y2 + <span class="number">1</span>]); <span class="comment">// 否则两个都加进去</span></span><br><span class="line">                <span class="keyword">if</span>(x2 + <span class="number">1</span> == x1) dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>]); <span class="comment">// 同理</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>] + a[x2 + <span class="number">1</span>][y2]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h2 id="P5322"><a href="#P5322" class="headerlink" title="P5322"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5322">P5322</a></h2><p>哇，上来这题弄得人毫无思路。</p>
<p>仔细瞅了瞅发现是个分组背包。</p>
<p>先想一个问题：派出的部队人数肯定严格大于对面的人数加 1，不然就是去白给，白给是肯定不能接受的。</p>
<p>那么，如何确定派出部队的方法呢？</p>
<p>观察到题目中派出部队的方法是相对于每一个阵地而言的，这样一来我们就可以按照每个阵地的角度上去思考，而不是从每个对手的角度去思考。</p>
<p>那么，我们就可以把到了哪一个阵地作为阶段，注意到剩余的部队人数也是一个不可或缺的附加维度，那么我们就应该将其也加入到状态中。</p>
<p>设 $dp_{i, j}$ 表示到了第 i 个阵地，还剩下 j 部队人数的最大受益值。</p>
<p>注意到第一维可以直接原地滚动数组秒掉，注意循环顺序，别无中生部队啊。</p>
<p>怎样更好地确定向每个阵地派出多少部队呢？</p>
<p>发现每个阵地上驻守的人数是无序的，也就是说是不好处理的，既然如此我们就把每个阵地上的人数升序排序，这样一来如果我们当前的部队人数能够击败第 k 个对手的，之前的对手肯定也都是可以击败的，这样一来我们就可以较为方便地处理向每个阵地派出的部队人数了。</p>
<p>这样方便了转移也方便了设计方程。</p>
<p>因为我们使用了滚动数组，转移时一定要注意先枚举部队人数然后再枚举每一个对手。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            a[j][i] = <span class="built_in">rd</span>();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">sort</span>(a[i] + <span class="number">1</span>, a[i] + <span class="number">1</span> + s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; ++k)</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">2</span> * a[i][k])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - a[i][k] * <span class="number">2</span> - <span class="number">1</span>] + k * i, dp[j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m]);</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Shelter Prime</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://dxrprime.github.io/2022/10/18/DP%20%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/">http://dxrprime.github.io/2022/10/18/DP%20%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>Lock and load. Let's roll. !!!!</strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Algorithm/"># Algorithm</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/10/27/2022.10.27%E6%95%B4%E7%90%86/">2022.10.27 整理</a>
            
            
            <a class="next" rel="next" href="/2022/10/14/2022.10.12%E6%95%B4%E7%90%86/">2022.10.12 整理</a>
            
        </section>


    </article>
</div>

  
    <div id="gitalk-container"></div>  
    <link rel="stylesheet" href="/gitalk/dist/gitalk.css">  
<script src="/gitalk/dist/gitalk.min.js"></script>  
<script src="/md5.min.js"></script>  
<div id="gitalk-container"></div>  
<script type="text/javascript">  
 var gitalk = new Gitalk({  
 clientID: 'd3009a5e8d9c427df8ba',  
 clientSecret: '0b0585b5051899c872936313348f9531451f6242',  
 repo: 'DxrPrime.github.io',  
 owner: 'DxrPrime',  
 admin: 'DxrPrime',  
 id: md5(location.pathname),
 labels: 'gitalk'.split(',').filter(l => l),  
 perPage: 15,  
 pagerDirection: 'last',  
 createIssueManually: true,  
 distractionFreeMode: true,  
 proxy: 'https://dxrprime.the-last-prime.workers.dev/?https://github.com/login/oauth/access_token',
 title: 'DxrPrime Shelter Comments'
 })  
 gitalk.render('gitalk-container')  
</script>  

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Shelter Prime | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
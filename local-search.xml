<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Summary on 2023.4.12</title>
    <link href="/2023/04/16/Summary%20on%202023.4.12/"/>
    <url>/2023/04/16/Summary%20on%202023.4.12/</url>
    
    <content type="html"><![CDATA[<h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h2><p>暴露出的问题是独立思考的能力不足，数学的基础不劳，D 的能力有亿点弱.</p><p>主要就是思考能力欠缺，十分欠缺，以后多 VP 一点比赛吧.</p><p>个人感觉难度：T3 &gt; T4 &gt; T2 &gt; T1，码力考察小，思考量也不是很大（<del>但虐死我足够了</del>）.</p><p>不过思考能力有着明显的进步，这是好事，而且做题太少是不够的，以后要多做题.</p><p>inv[i] = (p - p / i) * inv[i % p] % p;</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>会，不写了.</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>看到一个对着一个图进行修改的东西直接上去分层图就行了，这个方法一定要掌握.</p><p>然后发现这是一个 01 最短路，然后我们上去 01BFS 即可解决问题.</p><p>Code 很简单，不写了.</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>T3，看到整除考虑用质因子去思考.</p><p>有两种方法，但是本质是一样的.</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>这个方法需要 da♂rk 力打表找规律，并且思路有一点阴间，更推荐法二.</p><p>先考虑简单的问题，假如我们只用一个质数的 $i$ 次幂作为最后的结尾的数的数列有多少个.</p><blockquote><p>设 $dp_{i, j}$ 表示用 $i$ 次方，长度为 $j$ 的最后一个数列可以被 $p^i$ 表示的数列的个数.</p></blockquote><p><del>andy_lz 是真强，这种逆天的状态都能想出来.</del></p><p>定住最后的 $a_j$，我们来思考如何递推：</p><ul><li>当$a_{j - 1} = p^i$ 的时候，发现定住了，那么这时候的数列数就只能是 $dp_{i, j - 1}$，因为数列本质上没有变化.</li><li>当 $a_{j - 1} \ne p^i$ 的时候，发现这和 $a_{j} = p^{i - 1}$ 的情况下的数列是一样的.</li></ul><p>然后我们得到递推式：<br>$$<br>dp_{i, j} = dp_{i - 1, j} + dp_{i, j - 1}<br>$$<br>现在我们处理好了固定次幂下的数列个数，考虑下一步：如何扩展到多个质因子的次幂相乘的结果？</p><p>发现对于同样的 $i$ 次幂，数列的个数是固定的，无论使用哪一个质因子做底数.（当这个指数在值域范围内的时候.）</p><p>那么我们就可以直接考虑值域内的每一个数，它最终可以贡献出多少贡献.</p><p>我们求完了 $i$ 次幂，然后我们直接考虑把 $x$ 这个数做结尾会贡献多少的数，而且它还会被不同的分解.</p><p>假如 $x = a^i \times b^j$ 的话：</p><blockquote><p>以 $x$ 结尾的数的数列个数就是 $dp_{i, n} \times dp_{j, n}$，因为这样肯定最后能将 $x$ 乘出来，并且前边都是满足条件的数列.</p></blockquote><p>然后我们就可以对于每一个数，看一下它可以分解为某个质因子的多少的幂次方，然后乘上对应的答案数，最后把每个数的贡献总和加到一起，这样就解决了这个问题.</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">25</span>][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll sum[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line">ll pr[N];</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;count.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;count.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            dp[i][j] = (dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            pr[++tot] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * <span class="number">2</span>; j * j &lt;= m; j += i)</span><br><span class="line">                np[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; tmp &gt; <span class="number">1</span> &amp;&amp; j &lt;= tot; ++j) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( !(tmp % pr[j] ) )</span><br><span class="line">                tmp /= pr[j], ++cnt;</span><br><span class="line">            </span><br><span class="line">            sum[i] = (sum[i] * dp[cnt][n]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmp &gt; <span class="number">1</span>)</span><br><span class="line">            sum[i] = (sum[i] * dp[<span class="number">1</span>][n]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans = (ans + sum[i]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">20 30</span></span><br><span class="line"><span class="comment">200000 200000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>想要达到互质的效果，我们不妨也考虑最后的数是哪一个数.</p><p>最后的数肯定可以分解为一个算术基本定理的形式，我们用这个做一点事情：</p><blockquote><p>若干个质因子相乘，我们将这些质因子随机地放在前面的几个位置上，这是一个组合数问题，然后我们只需要将这些数从头到尾乘过来，不难满足题目要求.</p></blockquote><p>然后我们只需要处理组合数，然后处理逆元，然后做完了.</p><p>这个思路还是比较好推的，更推荐这个做法.</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h5><p>PS：此为 L_ndyz 的代码，博主懒得自己写一份了（，声明一下版权.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p=<span class="number">998244353</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[<span class="number">2000100</span>],A[<span class="number">2000100</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> A[y]*inv[x]%p*inv[y-x]%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=now;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(now%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">now/=i;cnt++;</span><br><span class="line">&#125;</span><br><span class="line">sum=sum*<span class="built_in">C</span>(n<span class="number">-1</span>,cnt+n<span class="number">-1</span>)%p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">sum=sum*<span class="built_in">C</span>(n<span class="number">-1</span>,cnt+n<span class="number">-1</span>)%p;</span><br><span class="line">&#125;</span><br><span class="line">ans=(ans+sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;gift.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">// freopen(&quot;gift.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">A[<span class="number">0</span>]=A[<span class="number">1</span>]=inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n*<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n*<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">A[i]=(A[i<span class="number">-1</span>]*i)%p;inv[i]=(inv[i<span class="number">-1</span>]*inv[i])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sol</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="built_in">fclose</span>(stdin);</span><br><span class="line"><span class="built_in">fclose</span>(stdout);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>拿到异或，肯定是要拆位考虑的.</p><p>想要总和为 $m$，并且每一个二进制位上的 1 的个数都为偶数，不妨按照每一个二进制位考虑，这样能够很方便地保证偶数的限制.</p><p>因为一个二进制位会对应 $n$ 个下标位置，而这些下标位置我们是可以随意摆放的，也就是从 $n$ 个物品中选择 $i$ 个物品，这是一个组合数问题，使用杨辉三角 $\mathcal{O}(n^2)$ 即可处理组合数.</p><p>然后我们就可以快乐地开搜，然后我们接一个记忆化上去，这样就可以快速地解决这个问题了.</p><h4 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll dp[<span class="number">25</span>][N];</span><br><span class="line">ll n, m, C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos, ll res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][res]) <span class="keyword">return</span> dp[pos][res];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">0</span>) <span class="keyword">return</span> dp[pos][res] = C[n][res];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; pos) * i &lt;= res; i += <span class="number">2</span>)</span><br><span class="line">        dp[pos][res] = (dp[pos][res] + <span class="built_in">dfs</span>(pos - <span class="number">1</span>, res - (<span class="number">1</span> &lt;&lt; pos) * i) % mod * C[n][i] % mod) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[pos][res];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;gift.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;gift.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">if</span>(m % <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">                C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">19</span>, m));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fclose(stdin);</span></span><br><span class="line">    <span class="comment">// fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Somthing-Else"><a href="#Somthing-Else" class="headerlink" title="Somthing Else"></a>Somthing Else</h2><ul><li><del>这次考试是我安排的.</del></li><li><del>题目是我选的，但我不知道题目的具体内容.</del></li><li><del>所以为什么 Ptilopsis_w 一个学图论的会出两个数学题啊.</del></li><li><del>后来知道被骗了，这是 Jekyll_Y 的题.</del></li></ul>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我在 2023 春季测试的故事</title>
    <link href="/2023/03/19/%E6%98%A5%E5%AD%A3%E8%81%94%E8%B5%9B2023/"/>
    <url>/2023/03/19/%E6%98%A5%E5%AD%A3%E8%81%94%E8%B5%9B2023/</url>
    
    <content type="html"><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>‽</p><p>监考老师是大舌头，“<del>向 CCF 实名投漱</del>”。</p><p>电脑时间不对，居然还停留在 2013 年 1 月 1 日（</p><p>读完一遍题之后发现 CCF 的题诙谐多了（</p><p>看到 T1 之后发现蛮简单的，用时间戳的思想就可以跑过。</p><p>然后 30min 敲完，自测 100pts。</p><p>来到 T2，发现不是很好做，就先来了一手 1e6 的数据，用调和级数做过去了，自测 30pts 到手。</p><p>然后开始思考 1e8，正面做不好弄，就容斥了一手。</p><p>然后发现了一些美妙的性质，利用这些性质继续往下推……</p><p><del>然后推不动了（我数学真菜啊）</del></p><p>但是发现样例比较好骗，然后就上去输了所有的样例，自测多拿到了 5pts。</p><p>来到 T3，发现是计算几何。</p><p>计算几何……我忘得精光，没想到这年头居然还有人出这种题（</p><p>然后就写了一手全排列，自测成功弄出了 30pts。</p><p>来到 T4，【后记】 一栏挺无语的（</p><p>应该是个鬼畜 DP，然后发现我并不会（</p><p>把 $k = 1$ 的 10pts 弄过去了，然后时间不大够了，就开始贪心。</p><p>明显这个贪心不对，但是它还是在自测时为我多赢下了 10pts。</p><p>洛谷自测：100 + 35 + 30 + 20 = 185。</p><p>比较丢人（</p><p>后来发现，是因为中途 fclose 丢掉了 10pts，结果变成了 100 + 30 + 30 + 30 = 190，差 5 pts 就成正式选手了（</p><p>可恶啊！</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fall 2019 ICPC-style Waterloo Local Contest，D</title>
    <link href="/2023/02/02/Fall%202019%20ICPC-style%20Waterloo%20Local%20Contest%EF%BC%8CD/"/>
    <url>/2023/02/02/Fall%202019%20ICPC-style%20Waterloo%20Local%20Contest%EF%BC%8CD/</url>
    
    <content type="html"><![CDATA[<p>谨以此博文，纪念 L_fire 的逝去，L_ndyz 的诞生。</p><p>一篇博文需要一张头图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/35gvu9xb.png"></p><p>Fall 2019 ICPC-style Waterloo Local Contest，D</p><p>ICPC 的题啊，还是 D 题啊，果然不简单（</p><p><a href="https://codeforces.com/gym/102367/problem/D">Link</a></p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>集训的时候 Ptilopsis_w 找我，让我去找 wljss，说让 wljss 看他的私信。</p><p>然后我就去了，强行阻止了正在玩游戏的 wljss，跟他说 Ptilopsis_w 找他。</p><p>然后我对于他们的聊天内容产生了兴趣，于是我回去问 Ptilopsis_w 他们说了什么。</p><p>然后 Ptilopsis_w 说 wljss 昨天给了他一个题，他 yy 了一个做法给他看。</p><p>我表示想看看那个题，然后……</p><p>然后我的噩梦就开始了。</p><p>后边……疯狂地想，要用的东西倒是想的差不多了。</p><p>但是呢，很多细节都没有想出来（太菜了），然后跑去找 Sunny_r，学会之后开始写，一写就 5kb，然后找 Sunny_r 调，被 Sunny_r 痛击了 n 下（真·<strong>物理</strong>攻击）之后终于切掉了此题。</p><p>这叫什么？这就叫做身心俱疲（</p><p><del>Sunny_r：Shelter_Prime 他还是挺乖巧的结果老是挨揍。</del></p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这题其实很简单，你只需要学会树剖，离线操作，线段树，数论分块就可以做了！</p><p>我们把题意简化一下：</p><p>给一棵 $n$ 个点的树，边权 $w_i$，有 $q$ 次询问，每次询问如 $s,t,x$，求 $\sum _{i \in path(s,t)} \lceil \frac{w_i}{x} \rceil$</p><p>最后的答案加 1。</p><p>我相信肯定有人上来直接一手区间和再除以给定的 x 的，但是这破绽也太明显了……</p><p>很明显的：ceil(1 / 3) + ceil(2 / 3) ≠ ceil(3 / 3)</p><p>不好做啊（</p><p>我们观察一下这个式子，我们是不是发现这跟数论函数蛮像的？</p><p>那我们是不是发现，这是隔一段数才会发生变化的？</p><p>欸？</p><p>又发现这个 x 才只有 2e4？</p><p>那我们是不是就可以来一手数论分块求一下对于除以一个数，会造成值改变的那些数都有什么？</p><p>但是发现树上的权值可能重复，于是我们记录一下一个权值对应的下放后的 dfn 值。</p><p>然后发现在线不好回答，于是我们直接一手离线，通过枚举 x，<strong>独立</strong>地修改线段树上的权值，然后直接统计和是不是就可以了？</p><p>离线之后要按 x 升序排序！</p><p>这里的修改是单点修改。</p><p>然后如果当前的 x 跟我们当前的询问对上了，我们就可以直接统计下答案输出就可以了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link: https://codeforces.com/gym/102367/problem/D</span></span><br><span class="line"><span class="comment">// Author: Shelter Prime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lk[N], ltp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">    e[++ltp] = &#123;v, lk[u], w&#125;;</span><br><span class="line">    lk[u] = ltp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dep[N], fa[N], son[N], siz[N];</span><br><span class="line"><span class="keyword">int</span> top[N], dfn[N], rk[N];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">ll ans[N];</span><br><span class="line">ll a[N];</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; numb[N]; <span class="comment">// 在 i 这个值下会发生改变的数</span></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; val[N]; <span class="comment">// 会发生数改变的 dfn 值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    ll x;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20000</span>; ++i) &#123; <span class="comment">// 考虑当前的被除数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= <span class="number">20000</span>; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((ll)<span class="built_in">ceil</span>(<span class="number">1.0</span> * i / l) == <span class="number">1</span>) &#123;</span><br><span class="line">                numb[l].<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                numb[l].<span class="built_in">push_back</span>(i);</span><br><span class="line">                r = <span class="built_in">ceil</span>(<span class="number">1.0</span> * i / (<span class="built_in">ceil</span>(<span class="number">1.0</span> * i / l) - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Ask x, Ask y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>, son[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dep[v]) &#123;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            a[v] = e[i].w;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span>(son[u] == <span class="number">-1</span> || siz[v] &gt; siz[son[u]])</span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    dfn[u] = ++num;</span><br><span class="line">    rk[num] = u;</span><br><span class="line">    val[a[u]].<span class="built_in">push_back</span>(dfn[u]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(son[u] == <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != fa[u] &amp;&amp; v != son[u])</span><br><span class="line">            <span class="built_in">dfs2</span>(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    ll dat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) tr[x].dat</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls (p &lt;&lt; 1)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs (ls | 1)</span></span><br><span class="line">    </span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="built_in">dat</span>(p) = a[rk[l]];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dat</span>(p) = <span class="built_in">dat</span>(ls) + <span class="built_in">dat</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">dat</span>(p) = delta;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) <span class="built_in">change</span>(ls, l, r, delta);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) <span class="built_in">change</span>(rs, l, r, delta);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dat</span>(p) = <span class="built_in">dat</span>(ls) + <span class="built_in">dat</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">dat</span>(p);</span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= mid) res += <span class="built_in">ask</span>(ls, l, r);</span><br><span class="line">    <span class="keyword">if</span>(r &gt; mid) res += <span class="built_in">ask</span>(rs, l, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">aask</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &lt; dep[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            res += <span class="built_in">ask</span>(<span class="number">1</span>, dfn[top[u]], dfn[u]);</span><br><span class="line">            u = fa[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dep[u] &gt; dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += <span class="built_in">ask</span>(<span class="number">1</span>, dfn[u] + <span class="number">1</span>, dfn[v]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">rd</span>(), v = <span class="built_in">rd</span>();</span><br><span class="line">        ll w = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">ins</span>(u, v, w);</span><br><span class="line">        <span class="built_in">ins</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print(1, 1, n);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">rd</span>(), v = <span class="built_in">rd</span>();</span><br><span class="line">        ll x = <span class="built_in">rd</span>();</span><br><span class="line">        </span><br><span class="line">        q[i].id = i, q[i].u = u, q[i].v = v;</span><br><span class="line">        q[i].x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= q[m].x; ++x) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numb[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; val[numb[x][i]].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, val[numb[x][i]][j], val[numb[x][i]][j], <span class="built_in">ceil</span>(numb[x][i] * <span class="number">1.0</span> / x));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(x == q[cnt].x) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[cnt].u, v = q[cnt].v;</span><br><span class="line">            ll res = <span class="built_in">aask</span>(u, v);</span><br><span class="line">            </span><br><span class="line">            ans[q[cnt].id] = res;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i] + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h2><p>Sunny_r：“我对码不对人。”</p><p>Sunny_r：“你的学长学姐都是好人，只是偶尔脾气暴躁而已。”</p><p>我：“偶尔？”</p><p>Sunny_r：“……”</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023.1.30 整理</title>
    <link href="/2023/02/02/2023.1.30/"/>
    <url>/2023/02/02/2023.1.30/</url>
    
    <content type="html"><![CDATA[<p>$\mathcal{Let’s\ roll.}$</p><p>谨以此博文，纪念 L_fire。</p><p>没想到 2023 年一个月过去了才重新开始写（</p><p>之前断更的有点厉害啊。</p><p>考的还算说的过去吧。</p><p>T1 签到题，T2 概率期望，T3 是奇妙的数据结构，T4 是模拟接高精。</p><p>问题就是一些学过的东西复习不够及时，一些套路还不是很会。</p><p>想期望的能力还是太烂了，多学学吧。</p><p>码力倒提升了点，至少模拟能敲出来了。（</p><p>T1 不写了，有手就行。</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>这一堆颜色……考虑期望是具有可加性的，我们就分别考虑每个颜色的贡献。</p><p>考虑该颜色时，其余颜色都可以视为一种颜色，毕竟都要变成该颜色，因此只要不一样就是异教徒（</p><p>设当前颜色为白色，其余皆为黑色。</p><p>然后我们开始想状态：</p><p>阶段是什么？发现到了第 i 个球并不能很好的表示状态（因为不好算），那么我们就转而去设有 i 个白球的状态。</p><p>来一手疯狂的 push 柿子就得到了下边的方程：</p><p>$dp[i] = \dfrac{C^2_n}{i(n - i)} + \dfrac{1}{2} * dp[i - 1] + \dfrac{1}{2} * dp[i + 1]$</p><p>好像还是蛮对的，但是<strong>有破绽</strong>!</p><p>破绽就是，你有没有想过一个问题，$dp[0]$ <strong>有意义</strong>吗？</p><p>一个白球都没有，岂不是正无穷次操作？</p><p>太妙了，然后你每个状态都成了正无穷，直接爆炸。</p><p>发觉这东西是个少一个限制的东西，我们必须要限制向能成功的方向去做。</p><p>$dp[i]$ 应该是有 i 个白球，在能全变成白球的条件下的期望步数。</p><p>我们先来一手概率，设 $g[i]$ 表示当前有 i 个白球全变成 n 个的概率。</p><p>易得：</p><p>$g[i] = \dfrac{1}{2}g[i - 1] + \dfrac{1}{2}g[i + 1]$。</p><p>初始化是：$g[0] = 0, g[n] = 1$。（<del>wljss 这里打错了 TwT</del>）</p><p>根据上边那个式子，移项，乘 2，然后发现这是个等差数列。</p><p>公差就可以弄出来，得出 $g[i] = \dfrac{i}{n}$。</p><p>根据期望的定义，我们可以用 $g[i]$ 来弄出新的 dp 的两个新的系数。</p><p>然后我们弄出：</p><p>$dp[i] = \dfrac{C^2_n}{i(n - i)} + \dfrac{(i - 1)}{2i} * dp[i - 1] + \dfrac{i + 1}{2i} * dp[i + 1]$</p><p>然后发现这个东西是可以高斯消元的，可以用 $\mathcal{O}(n^3)$ 的复杂度通过 80 pts 的数据。</p><p>但是我们发现一个问题，这个矩阵它并不满，而且几乎全在对角线附近。</p><p>然后我们就可以改的少亿点，这样就可以 $\mathcal{O}(n)$ 过了。</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>我说这是个国家集训队的题你信吗？</p><p>我说这是个 CTSC 选拔的模拟赛的题你信吗？</p><p>不过赛时还是拿到了 64pts 的成绩，不是太高但也说得过去。（<del>可能只是 wljss 的数据太善良了？</del>）</p><p>赛场上我是看出了一些端倪的，就是存在一个等差数列，正序逆序都行，序列就可以了，满足这个序列长度至少为 3 即可。</p><p>然后我直接一手 DP（</p><p>正解当然不是 DP，毕竟我想了很长时间也想不出来这东西怎么优化（</p><p>考虑这是一个全排列的问题，所以先一手转换成桶来做。</p><p>当我们处理到 i 时，将 $t[a[i]]$ 标记为 1。</p><p>如果此时以 $a[i]$ 为中心，我们将左右边界尽可能地扩展，直到有一边顶到了边界，然后拿出这一段，这会是一个 01 串，1 表示这个数在 $a[i]$ 之前出现过，0 表示未出现过，如果发现这并不回文，也就是满足 $t[a[i] -j] \ne t[a[i] + j]$ </p><p>那么是不是说明此时满足的题目的条件？</p><p>那我们该如何快速判断回文串呢？</p><p>我们用树状数组维护一个动态 Hash 就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解：P2446【大陆争霸】</title>
    <link href="/2023/01/30/P2446%E3%80%90%E5%A4%A7%E9%99%86%E4%BA%89%E9%9C%B8%E3%80%91%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/01/30/P2446%E3%80%90%E5%A4%A7%E9%99%86%E4%BA%89%E9%9C%B8%E3%80%91%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>$\text{For in the end, I shall become the last one, who stand victories!}$</p><p>翻译一下（<del>与原文极度不符，这边建议看原文</del>）：我记得我被这题恶心了 5 遍了，每一遍听都没透彻，第五遍An过后决心弄透彻掉，然后就明白了，然后就写篇题解纪念一下对这道题最终的胜利。</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>题目中有些城市是被保护着的，必须先解决掉所有保护它的城市才能解决掉它。</p><p>初看并不好做，实际上我们可以考虑用到达它的时间和炸掉它的时间，这两者取 $\max$ 即为到达这座城市的实际时间。</p><p>设到达第 $i$ 号城市的时间为 $\operatorname{arr_i}$，能进入（也即是<strong>将全部的防御炸光</strong>的时间）为 $\operatorname{ent_i}$。</p><p>如果实际进程的时间为 $\operatorname{dis_i}$，那么根据定义可知：</p><p>$\operatorname{dis_i} = \max(arr_i，ent_i)$</p><p>考虑到达一个点的实际情况是这样的：</p><ol><li><p>我们到了，但是防御没有全部攻破，这时候我们只能等待。</p></li><li><p>我们还没到，但是防御早拆完了，这时候我们得等它赶过去。</p></li></ol><p>这就是上式的原因。</p><p>那么，$\operatorname{arr}$ 如何求呢？</p><p>我们发现，到达一个点的时间就是实际进入起点的时间加上边权，这样我们求出了 $\operatorname{arr}$。</p><p>$\operatorname{arr_v} = \min(\operatorname{arr_v}, \operatorname{dis_u + w})$</p><p>其实这就是个最短路的事，但我们要让其尽可能得小。</p><p>$\operatorname{ent}$ 呢？</p><p>考虑到击破全部防御的时间无非就是实际进入所有能防御这个城市的城市的时间，在这些实际时间里取 $\max$ 即可。</p><p>注意，$\operatorname{ent}$ 数组不要初始化成正无穷！因为你要取 $\max$！</p><p>$\operatorname{ent_v} = \max(\operatorname{ent_v}, \operatorname{dis_u})$</p><p>具体如何实现呢？</p><p>我们直接在 $\text{Dijkstra}$ 的时候，更新 $\operatorname{arr}$，并更新 $\operatorname{ent}$，两者顺序无所谓，只要你在更新两者的同时不要忘记更新 $\operatorname{dis}$ 即可。</p><p>最后，一定要<strong>读清</strong>题！</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>, M = <span class="number">7e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, nxt;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>], pro[M &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lk[N], ltp;</span><br><span class="line"><span class="keyword">int</span> lkp[N], ltpp;</span><br><span class="line"><span class="keyword">int</span> in[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">ll arr[N], ent[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">    e[++ltp] = (Graph) &#123;v, lk[u], w&#125;;</span><br><span class="line">    lk[u] = ltp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins_pro</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    pro[++ltpp].v = v, pro[ltpp].nxt = lkp[u];</span><br><span class="line">    lkp[u] = ltpp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span> &#123;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> HN HeapNode</span></span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    ll dis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> HN &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">HN</span> (<span class="keyword">int</span> pos, ll dis) : <span class="built_in">pos</span>(pos), <span class="built_in">dis</span>(dis) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    arr[s] = <span class="number">0</span>;</span><br><span class="line">    ent[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue &lt;HN&gt; q;</span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">HN</span>(s, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">top</span>().pos;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lkp[u]; i; i = pro[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = pro[i].v;</span><br><span class="line">            ent[v] = <span class="built_in">max</span>(ent[v], dis[u]);</span><br><span class="line">            --in[v];</span><br><span class="line">            <span class="keyword">if</span>(!in[v]) &#123;</span><br><span class="line">                dis[v] = <span class="built_in">max</span>(ent[v], arr[v]);</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">HN</span>(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            ll w = e[i].w;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(arr[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                arr[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span>(!in[v]) &#123;</span><br><span class="line">                    dis[v] = <span class="built_in">max</span>(ent[v], arr[v]);</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">HN</span>(v, dis[v]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;P2446.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;P2446.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">rd</span>(), v = <span class="built_in">rd</span>();</span><br><span class="line">        ll w = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">ins</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        in[u] = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">ins_pro</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, dis[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fclose(stdin);</span></span><br><span class="line">    <span class="comment">// fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论分块</title>
    <link href="/2022/12/31/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"/>
    <url>/2022/12/31/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wobuw5k2.png"></p><p>很久没有写博文力。</p><p>在 2022 年的最后一天发篇博文吧。</p><p>何为数论分块？</p><p>出现这种式子，直接数论分块：</p><p>$\sum\limits_{i = 1}^{n} \left\lfloor\dfrac{n}{i}\right\rfloor$</p><p>不难发现朴素的方法是 $\mathcal{O}(n)$。</p><p>但这样直接搞是会 van 的。</p><p>正确的操作是使用数论分块，达到 $\mathcal{O}(\sqrt{n})$ 的级别。</p><p>考虑求和的对象：$\left\lfloor\dfrac{n}{i}\right\rfloor$</p><p>我们会发现这个东西是隔一段变化一次的。</p><p>毕竟加上了向下取整，相当于是一个整数的运算。</p><p>那么寻找这个变化的位置，以这个位置为分界点进行一个分块，每块我们只计算一次，乘上块长就好力。</p><p>给一个证明吧：</p><p>设左端点为 l，右端点为 r，单点值为 k。</p><p>很明显嘛：$k = \left\lfloor\dfrac{n}{l}\right\rfloor = \left\lfloor\dfrac{n}{r}\right\rfloor$</p><p>对于 $i \in [l, r]$，r 肯定是所有 i 的最大取值，易得 $i \times k \le n, i \le \dfrac{n}{k}$。</p><p>就可以：</p><p>$r = \left\lfloor\dfrac{n}{k}\right\rfloor = \left\lfloor\dfrac{n}{\left\lfloor\dfrac{n}{l}\right\rfloor}\right\rfloor$</p><p>注意！这里不能直接让 r = l！因为这些都是整数下的除法并且加了向下取整！</p><p>举个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> / (<span class="number">10</span> / <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>考虑到向下取整，这个得数是 5，如果直接等于过去则会是 4！喜爆。</p><p>这样有了左右端点又有了单点值，我想是人就能弄出来了吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans = ans + (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在您已经入门力！</p><p>上点题吧：</p><p><a href="https://www.luogu.com.cn/problem/UVA11526">UVA11526</a></p><p>原题，但是注意 n = 0 的情况，否则您会当场 RE（。</p><p>然后是这个：</p><p><a href="https://www.luogu.com.cn/problem/P2261">P2261</a></p><p>把取模运算换一换，然后拆开算，左边能 $\mathcal{O}(1)$ 解决，右边是一个对于 k 的数论分块，考虑到乘的数不一样，直接换算成平均数乘总个数，做完力。</p><p><a href="https://www.luogu.com.cn/problem/P3935">P3935</a></p><p>考虑如何快速求约数个数。</p><p>约数个数无非就是 $\left\lfloor\dfrac{n}{i}\right\rfloor$。</p><p>考虑 i 对于每一个倍数都产生贡献，因此每一个 i 的贡献就是 i 的倍数个数。</p><p>接一个数论分块，问题解决。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我在 CSP-S 2022 的故事</title>
    <link href="/2022/10/30/CSP-S2022/"/>
    <url>/2022/10/30/CSP-S2022/</url>
    
    <content type="html"><![CDATA[<h1 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>整体目标：练习枚举，搜索等暴力骗分手段。</p><p>上午：袁野课程，模拟，搜索， DP， 复习模板。</p><p>下午：练习，然后就是 numb。</p><p>晚上听 whk。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>上午打了场洛谷月赛的 J 组，260 pts，感觉不太行。</p><p>下午本来计划比赛 S 组，但是题太难了直接摆烂，学一下午 DP，结果 numb 了，晚上乱搞了点 WSL 和 gdb，挺快乐。</p><p>回宿舍的时候嫖了点吃的，差点让 Ptilopsis_w 他们给玷污了。</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>早上和教练们共进早餐。</p><p>上午学完剩下的 DP，然后开始练习，有了 SSH 感觉 WSL 太快乐了。</p><p>下午计划继续听课，钻研了 2 个小时总算是弄明白了一道 DP。(菜的要死)</p><p>晚上 numb 了，whk 也懒得听了。</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>又是和教练们共进早餐的一天呢。</p><p>学习了一下状压 DP，感觉有些 numb。听了听 A* 感觉挺透彻，写了几个题还算是快乐。</p><p>下午日常 numb……写了个高精愉悦身心，然后试着写状压 DP 发现写不出来（实在是太 numb了）。</p><p>然后就……写了点 DS 的模板，提前学了一会 whk。</p><p>写 Kruskal 的时候发现在 LiuTianyou 电脑上那个为我开的 folder 里边多了一个叫 DxrNB!!!!!! 的 txt 文件，点开以后发现里边赫然写着：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This folder is for Dxr.</span><br><span class="line">He is so NB!</span><br></pre></td></tr></table></figure><p>az，绝了。</p><p>晚上依旧 numb……</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>上午图论，meet-in-the-middle，生成树，最短路，分层图……</p><p>下午开始疯狂切题，极度快乐。计划复习 Splay，Treap，高精度，熟练剖分，LCA，双向搜索，广搜，DAG……</p><p>没写完，时间不够了，晚上就没搞 whk。</p><p>晚上写了一道初中 dalao 们以前做过的模拟题，砍下了人生中第一个最优解。</p><p>后来发现，这题就是个 BF。S 组模拟，但是 T1 是 BF！</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>打了一场 S 组模拟赛，感觉非常不行。</p><p>中午和 Ptilopsis_w 和另一位 dalao 共进午餐。</p><p>下午讲评光弄懂了个 T1，别的实在是知识点不够理解不了，还得学。</p><p>晚上打各类模板，whk 直接就扔掉不管了。</p><p>CSP2022 RP++……感觉蛮慌乱的。</p><p>复习了一下对拍，复习了下平衡树，然后看了看历年真题感觉还挺透彻的。</p><p>玩了玩 WSL，打了个 Trie 模板，放平了心态。</p><p>晚上切掉了模拟五十的 T1，<del>跑的比 Ptilopsis_w 快多了</del>，总体上就是纵向做一个前缀和，横向用双指针维护一个子区间和，做两次就好了。</p><p>这样就可以很方便的维护一个子矩形里边有多少个 1，十分的舒适。</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><p>最后一天了。</p><p>上午敲了一堆 DS，下午考了次 S 组模拟赛。</p><p>感觉考得还不错，T1 是个博弈论，很快切掉了。</p><p>T2 是个比较变态的换根 DP，而且我还不会换根 DP……于是我就是用了传说中的 $n$ 遍 DFS。</p><p>为了更好地处理区间加，我预先进行了树链剖分，然后接一个树上差分，但是我的树上差分能力明显不足导致调了两个小时才写出来一个 30pts 的 BF，这时候基本上只剩 10 min 了，T3 随手敲了个 10 pts 的 dfs 就完了。</p><p>晚上看看了题解，加了一堆 RP，看了点技巧，玩了玩对拍，翻了翻自己的博文，准备了一下考试。</p><h1 id="CSP-S-2022"><a href="#CSP-S-2022" class="headerlink" title="CSP-S 2022"></a>CSP-S 2022</h1><p>上午进行最后的备考，狂敲各种模板。</p><p>下午，Let it begin！</p><h2 id="Day1-1"><a href="#Day1-1" class="headerlink" title="Day1"></a>Day1</h2><p>今年这密码有点离谱啊……belief2022……</p><p>一遍敲对，十分舒适。</p><p>看完四个题之后<del>断定都不可做</del>，然后看了下 T1 感觉前 40pts 极其好写，随便写写就过了样例（然而还是调了一会，原因是题没读清，下次读慢点。）</p><p>T1 敲完 BF 后来看 T3，感觉不是很好写，回到 T2，由于我并不能推出这题的结论（太菜了啊），我就照着数据编程。发现几个限制条件下结论还是很好推的，限制 1 直接维护区间最大值和区间最小值就好了。</p><p>但……为什么考场上玩的样例都对了但是民间自测爆 0 了……完蛋了。</p><p>然后 T3 狂写一顿，用一个极其离谱的方法过了样例（我自己都不知道怎么过的）</p><p>T4 就一顿乱写……胡过了样例，但是明显不大对劲。</p><p>后来测 T4 的时候抱灵了，但是 T3 莫名其妙拿了 40pts……</p><p>如果不贪 T4 的 BF 的话，可能我就 145 了吧，现在却只有 80……</p><p>I am so sad.</p><p>由于狂写 T3，T4 的 BF 导致 T2 的做法没时间查，结果很慌乱，导致没时间改，估计是没戏了。</p><p>下次写完之后先检查再往下写吧……反正后面的分估计也拿不到，不如把前面的检查一下算了。</p><p>完蛋了啊！！！！</p><p>现在就指着 noip 打场翻身仗了！</p><p>NOIP2022，加油！</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来发现 T2 没开 long long，Luogu 数据十分强大，开了 long long 之后获得了 65pts 的好成绩。</p><p>CCF 应该不会把数据弄成这么强吧……现在我有从 80pts~145pts 的成绩，感觉上三位数的概率还是蛮大的。</p><p>如果运气好的话，就可以蓝钩了吧。</p><p>下次，一定要把值域开成 long long，不然今年这 145 就稳了，也不至于挂分了。</p><p>回学校之后得隔离，LiuTianyou 怕黑非得跟我挤在一间屋子，导致他只能睡桌子（</p><p>现在得学 whk 了啊……</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022.10.27 整理</title>
    <link href="/2022/10/27/2022.10.27%E6%95%B4%E7%90%86/"/>
    <url>/2022/10/27/2022.10.27%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p>算是第一次线下做 S 组模拟题吧（其实并不知道具体难度是在 S 还是在省选，不过个人感觉就是个 S 组，虽然只有三个题），但是我就相当于一个旁观者，所以也没有测评代码，纯属自行估分。</p><p>感觉自己不会的东西还是非常多的，比如数据结构会但是想不到怎么用，想正解的能力还是太差了，如果碰上个简单的 T1（指能用 BF 干对的或是稍微预处理点就行的）可能还有救，然而概率太低了。</p><p>总之多写写结论题和思维题吧。</p><p>开题之后通读题面，<del>断定三个题都不可做</del>，感觉 T2 比较难就先放过去，开始写 T1。</p><p>研究 T1 的时候尝试加一些限制，确实在没有重复元素的情况下推出了正解并且愉快地爆碾了样例，但是再向有重复的元素扩展时没有成功，感觉单靠数学结论不大行了，就开始套 DS 去优化，然后乱搞了一顿，貌似能对（没写对拍）。</p><p>T1 是个 DS，但是我处理的方法非常笨，我将 $\mathcal{O}(n^2)$ 个区间全丢进去，这样导致最后四个数据是肯定没救的，如果写对了也就 60pts，极限分了。</p><p>T2 是个比较难的树上问题，是个树上差分，还是 DS，然而架不住菜，写了个 20pts 的 BF 就走了，不过这 20pts 给的是真舒适<del>如果能再多点就好了</del>。</p><p>事后证明，由于太过 BF，导致全 T……嘤嘤嘤……</p><p>T3 居然和 Stirling 数有关，我还在 solution 里瞅见了多项式……不过好像也就用到了证明性质，也不用手敲。T3 是单调栈然而自己过于菜导致没想到（<del>想到了也不会</del>），想了半天还是只能写个 10pts 的 BF……（这波靠 BF 活着了属于是），就死活优化不下去，后来想到了 DP（本场 contest 为数不多的和正解沾边的操作），然后试着写了写但还是挂掉了。</p><p>为什么我这么<strong>菜</strong>啊！</p><p>如果做法正确的话也就 90pts，不大行，任重而道远。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>思维题。</p><p>看一个区间包含多少个数有点麻烦，不妨转化为看一个数在多少个区间里。这样枚举可以节省时间，非常舒适。</p><p>令 $pre_i$ 表示 $a[i]$  上一次出现的位置。数据范围有点大，我就不离散化（，我直接 map，简单又舒适。</p><p>对于重复的数的贡献，我们直接考虑最左边的一个，发现这个东西可以对前边 $i - pre_i$ 个区间产生贡献，也能对后边的 $n \times k - i + 1$ 个区间产生贡献。</p><p>因此总答案就是 :$\sum\limits^{k \times n}_{i = 1}{(i-pre_i)\times(k\times n-i+1)}$。</p><p>我们可以拆开算，发现右边的那一堆就是个等差数列，可以直接 $\mathcal{O}(1)$ 求出来，右边那一堆是不变的。</p><p>需要注意，当这个数是第一次出现的时候是需要特判一下的，因为此时它需要额外把前面所有的区间的贡献全部加上。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line">ll k, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line">map &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">bool</span> fl[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % mod + b % mod) % mod * c % mod *inv2 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">// freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    n = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(a[i])) pre[i] = mp[a[i]];</span><br><span class="line">        <span class="keyword">else</span> fl[i] = <span class="literal">true</span>;</span><br><span class="line">        mp[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span>(!pre[i] &amp;&amp; mp[a[i]] != i) pre[i] = mp[a[i]];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fl[i] &amp;&amp; !pre[i]) pre[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fl[i]) &#123;</span><br><span class="line">            ans = (ans % mod + ( <span class="number">1ll</span> * i % mod * <span class="number">1ll</span> * (n % mod * k % mod - i + <span class="number">1</span>) % mod) % mod) % mod;</span><br><span class="line">            ans = (ans % mod + ((n + i - pre[i]) % mod * <span class="built_in">calc</span>((n % mod * (k - <span class="number">1</span>) % mod - (i - <span class="number">1</span>) % mod) % mod, n - i + <span class="number">1</span>, k - <span class="number">1</span>) % mod) % mod) % mod;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = (ans % mod + (i - pre[i]) % mod * <span class="built_in">calc</span>(((n % mod * k % mod - i + <span class="number">1</span>) % mod) % mod, n - i + <span class="number">1</span>, k) % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附带对拍数据生成器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    uniform_int_distribution &lt;<span class="keyword">int</span>&gt; <span class="built_in">rg1</span>(<span class="number">1</span>, <span class="number">1e5</span>);</span><br><span class="line">    uniform_int_distribution &lt;<span class="keyword">int</span>&gt; <span class="built_in">rg2</span>(<span class="number">1</span>, <span class="number">1e9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">rg1</span>(rd);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">rg1</span>(rd) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">rg2</span>(rd) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调试之路：</p><p>首先先跟丙戌年 dalao 学到了思路，顺便要到了 ACCode，然后开始钻研，然后开始写，接下来上去交了好几遍都是 30pts，气急败坏之下开始对拍，小数据都是 AC，大数据都爆炸。</p><p>最后经过多次研究，发现除法不能取模，被迫写成逆元，然后拍了遍大数据发现对了，接下来就 A 掉了。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>枚举 4 个点，得到 20 pts。</p><p>预处理出长度为 p，q 的路径，再判断。</p><p>判断路径相交用到 LCA，玩 tarjan 可以快点。</p><p>正着求有点难受，直接正难则反吧。</p><p>然后就不会了……</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>dp，但是我听不懂……</p><p>我太菜了，见谅好吧，等我研究透 Solution 再说。（也许需要很长的时间……）</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP 练习记录</title>
    <link href="/2022/10/18/DP%20%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/18/DP%20%E7%BB%83%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="P4310"><a href="#P4310" class="headerlink" title="P4310"></a><a href="https://www.luogu.com.cn/problem/P4310">P4310</a></h2><p>类似最长上升子序列，我们可以推出以下式子：</p><p>$\text{dp} = \max{dp_j + 1}, j &lt; i$</p><p>并且 a[i] &amp; a[j] 不为 0。（为什么不写进 $\LaTeX$ 呢？因为新博文的并不支持 &amp; 这个东西，一用就挂。）</p><p>考虑位运算的特性，每一位并不相关，那么我们可以让 $dp_i$ 表示 二进制下第 i 位为  1 的最大值，这样我们每次找到一个数直接给他二进制拆分，先更新当前最大值，然后拿最大值去更新  dp 数组，这样时间复杂度就变成了 $\mathcal{O}(n \log n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j) <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) tmp = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">64</span>; ++j) <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) dp[j] = <span class="built_in">max</span>(dp[j], tmp);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="P2184"><a href="#P2184" class="headerlink" title="P2184"></a><a href="https://www.luogu.com.cn/problem/P1284">P2184</a></h2><p>不是很方便知道具体的边长，那么我们就转换思路为看能否圈出 a，b，c 长度的三条边。</p><p>则 $dp_{a, b, c}$ 表示能否围成 a，b，c 三条边。</p><p>一算空间爆掉了，想办法优化。</p><p>因为周长已知，那么我们只需要知道两条边即可推出第三边，那么我们就可以优化成：</p><p>$$dp_{i, j, k}$$ 表示第 i 个点，长度为 j，k 两条边能否围成。</p><p>经过研究可以发现，我们可以直接原地滚动数组，第一维直接省略掉，转化为。</p><p>考虑状态转移方程：</p><ol><li>如果我们将当前边放到 j 处，则我们需要通过 $dp_{j - a_i, k}$ 推过来。</li><li>如果我们将当前边放到 k 处，则我们需要通过 $dp_{j, k - a_i}$ 推过来。</li><li>如果我们将当前边放到第三条边，我们只需要 $dp_{j, k}$ 推过来。</li></ol><p>那么状态转移方程为：$dp_{i, j} |= (dp_{i - a_k, j}, dp_{i, j - a_k})$</p><p>现在我们已知了可以到达的边，去枚举这些边，然后判断是否可以凑出这三条边，再看能否围成三角形，最后统计答案输出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum &gt;&gt; <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = sum &gt;&gt; <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= a[i]) dp[j][k] |= dp[j - a[i]][k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= a[i]) dp[j][k] |= dp[j][k - a[i]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = sum; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">is_ok</span>(i, j, sum - i - j)) <span class="keyword">continue</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">calc</span>(i, j, sum - i - j));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="P1133"><a href="#P1133" class="headerlink" title="P1133"></a><a href="https://www.luogu.com.cn/problem/P1133">P1133</a></h2><p>首先分析题意，可以得出线性 DP。</p><p>一维肯定不够，我们需要知道上一个子问题状态选择了哪一棵树，因此加上一维，这样最初的状态就变成了：$dp_{i, \ 0/1/2}$，表示到了第 i 个位置，放高度为 10，高度为 1，高度为 2 的树的最大收益。</p><p>坑人的是，我们依旧无法转移，因为我们没办法知道这个树是比左右都低还是比左右都高。</p><p>那就，再塞进去一维！</p><p>现在变成了：$dp_{i, \ 0/1/2, \ 0/1}$ 表示第 i 个位置，放高度为 10，高度为 1，高度为 2 的树，并且当前的树比左右两边都矮或比左右两边都高的最大收益。</p><p>现在好像可以做了，我们推一下状态转移方程：</p><p>$$dp_{i, 0, 0} = \max{dp_{i-1, 1, 1}, dp_{i - 1, 2, 1}} + a[i]$$</p><p>$$dp_{i, 1, 0} = dp_{i - 1, 2, 1} +b[i]$$</p><p>$$dp_{i, 1, 1} = dp_{i - 1, 0, 0} + b[i]$$</p><p>$$dp_{i, 2, 1} = \max{dp_{i - 1, 0, 0},\  dp_{i - 1, 1, 0}} + c[i]$$</p><p>考虑一下初始化，直接设成 0 就可以了。</p><p>最后答案枚举最后一颗树的种类状态即可。</p><p>来一波操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]) + a[i];</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + b[i];</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + b[i];</span><br><span class="line">        dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[n][i][j]);</span><br></pre></td></tr></table></figure><p>然后我们壮烈地牺牲了 30 pts。</p><p>分析一下原因我们发现，我们未能正确处理好最后一棵树和第一颗树的关系，因此导致了 WA。</p><p>那我们就不得不换种思路：先枚举第一颗树的状态，然后以这个状态为基础去更新接下来的位置，然后在更新的途中就把最大值取了。</p><p>现在我们过了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k)</span><br><span class="line">                dp[<span class="number">1</span>][i][k] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">1</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">2</span>) dp[<span class="number">1</span>][j][<span class="number">0</span>] = dp[<span class="number">1</span>][j][<span class="number">1</span>] = c[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>]) + a[i];</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + b[i];</span><br><span class="line">            dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + b[i];</span><br><span class="line">            dp[i][<span class="number">2</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]) + c[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i) ans = <span class="built_in">max</span>(ans, dp[n][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &gt; j; --i) ans = <span class="built_in">max</span>(ans, dp[n][i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="POJ1742"><a href="#POJ1742" class="headerlink" title="POJ1742"></a><a href="http://poj.org/problem?id=1742">POJ1742</a></h2><p>一眼多重背包，上去先来个朴素的解法，成功过了样例，然后 TLE 了。</p><h3 id="朴素"><a href="#朴素" class="headerlink" title="朴素"></a>朴素</h3><p>首先可以看出这是个多重背包，那么我们就可以将每一个物品分出来，按照 01 背包那么折腾，这样时间复杂度是 $\mathcal{O(m\sum_{i=1}^{n}c_i)}$ ，毫无疑问地去世。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = m; k &gt;= a[i]; --k)</span><br><span class="line">                dp[k] |= dp[k - a[i]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += dp[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制拆分"><a href="#二进制拆分" class="headerlink" title="二进制拆分"></a>二进制拆分</h3><p>既然朴素的没辙，那我们就玩一下之前学过的二进制拆分来优化一下这个东西。</p><p>但是这样的时间复杂度是 $\mathcal{O(m\sum_{i=1}^{n}\log{c_i})}$，但是数据实在是太强大了，依旧超时。</p><p>不过至少能优化掉一大片吧……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c[i]; j &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                b[++tot] = j * a[i];</span><br><span class="line">                c[i] -= j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c[i]) b[++tot] = a[i] * c[i];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= b[i]; --j)</span><br><span class="line">                    dp[j] |= dp[j - b[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            ans += dp[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>注意啊，这里只是在怎么决策的时候贪心了一下，整体上还是 DP。</p><p>我们发现一个奇妙的性质：这题我们只要可行性就好了，不需要最优性。</p><p>既然如此，如果前 i 种硬币能拼成 j，只有两种可能：</p><ol><li>j 早就被拼出来了。</li><li>用一下第 i 种硬币拼成 j。</li></ol><p>很明显，我们能用 1 解决的就不用 2 解决。这样我们设一个 $used_j$ 表示让 $dp_j$ 在 i 阶段时为 true 至少需要多少种第 i 枚硬币，能用 1 就用1，并且将 $used_j$ 设成 0，这时候不需要第 i 种硬币来解决问题。</p><p>否则，考虑用当前硬币解决问题，退回到上一个状态，看一下那个状态耗费的第 i 种硬币数是否比给定的数量少，如果少的话并且那个状态已经拼出来了，我们就转移，否则就……</p><p>终于，时间复杂度被我们弄成了 $\mathcal{O(nm)}$，总算是过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) used[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(!dp[j] &amp;&amp; dp[j - a[i]] &amp;&amp; used[j - a[i]] &lt; c[i])</span><br><span class="line">                dp[j] = <span class="literal">true</span>, used[j] = used[j - a[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += dp[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1006"><a href="#P1006" class="headerlink" title="P1006"></a><a href="https://www.luogu.com.cn/problem/P1006">P1006</a></h2><p>线性 DP，我们先来分析一下状态，很明显，我们可以将当前路径的长度作为状态。</p><p>我们依然需要知道当前的末尾位置，因此我们还要想方设法地折腾出表示两个末尾位置的方法。</p><p>经过仔细的分析我们发现：我们走过的路径 $i$，和两个末尾节点的坐标 $x1, y1$， $x2, y2$ 的关系是这样的：</p><p>$i + 2 = x1 + y1 = x2 + y2$</p><p>注意，初始点的位置并不算进经过的路径中。</p><p>那么我们现在就可以用三个状态推知剩下的两个状态了：</p><p>$$y1 = i + 2 - x1, y2 = i + 2 - x2$$</p><p>这样一来我们就可以通过枚举三个维度，从而得到另外两个维度的信息。</p><p>设：$dp_{i, x1, x2}$ 表示路径长度为 i，一条路径的末节点的横坐标为 x1，另一条为 x2。</p><p>考虑 $x1 = x2$ 的转移：</p><ol><li><p>如果当前 $x1 = x2$，那么向下走的时候会走到同一个节点上，那么我们就只能取一次值：$dp_{i + 1, x1 + 1, x2 + 1} = \max{dp_{i + 1, x1 + 1, x2 + 1}, dp_{i, x1, x2} + a_{x1, y1 + 1}}$</p></li><li><p>如果当前 $x1 = x2$，那么向右走的时候也会走到同一个节点上，同理：$dp_{i + 1, x1, x2} = \max{dp_{i + 1, x1, x2}, dp_{i, x1, x2} + a_{x1 + 1, y1}}$</p></li></ol><p>当 $x1 = x2 + 1$ 或 $x2 =x1 + 1$</p><ol><li><p>这时候向下走就要考虑一下了，因为一个节点会走到曾经取走过的节点上，这时候我们就要考虑一下向下更新的问题了。如果 $x1 + 1 = x2$，说明 x1 在 x2 的斜右上边，这时候我们先让 x1 走到与 x2 相同的位置上，此时我们只能够取到 $a_{x1 + 1, y1}$ 的位置上的价值（如果看不懂可以自行画图理解）。</p></li><li><p>第二种情况同理呦。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x1 = <span class="number">1</span>; x1 &lt;= n &amp;&amp; x1 &lt;= i + <span class="number">1</span>; ++x1)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x2 = <span class="number">1</span>; x2 &lt;= n &amp;&amp; x2 &lt;= i + <span class="number">1</span>; ++x2) &#123;</span><br><span class="line">                <span class="keyword">int</span> y1 = i - x1 + <span class="number">2</span>, y2 = i - x2 + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x1 == x2) &#123; <span class="comment">// 当两端点的横坐标在同一水平位置上</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>]); <span class="comment">// 横着走只能更新一次</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1]); <span class="comment">// 竖着往下走也只能更新一次0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][x1][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>] + a[x2][y2 + <span class="number">1</span>]); <span class="comment">// 横着走两个都加</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1] + a[x2 + <span class="number">1</span>][y2]); <span class="comment">// 竖着走也无妨</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(x1 + <span class="number">1</span> == x2) dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1]); <span class="comment">// 要是竖着走到了同一个地方，只更新一下就可以</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1 + <span class="number">1</span>][x2], dp[i][x1][x2] + a[x1 + <span class="number">1</span>][y1] + a[x2][y2 + <span class="number">1</span>]); <span class="comment">// 否则两个都加进去</span></span><br><span class="line">                <span class="keyword">if</span>(x2 + <span class="number">1</span> == x1) dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>]); <span class="comment">// 同理</span></span><br><span class="line">                <span class="keyword">else</span> dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][x1][x2 + <span class="number">1</span>], dp[i][x1][x2] + a[x1][y1 + <span class="number">1</span>] + a[x2 + <span class="number">1</span>][y2]);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h2 id="P5322"><a href="#P5322" class="headerlink" title="P5322"></a><a href="https://www.luogu.com.cn/problem/P5322">P5322</a></h2><p>哇，上来这题弄得人毫无思路。</p><p>仔细瞅了瞅发现是个分组背包。</p><p>先想一个问题：派出的部队人数肯定严格大于对面的人数加 1，不然就是去白给，白给是肯定不能接受的。</p><p>那么，如何确定派出部队的方法呢？</p><p>观察到题目中派出部队的方法是相对于每一个阵地而言的，这样一来我们就可以按照每个阵地的角度上去思考，而不是从每个对手的角度去思考。</p><p>那么，我们就可以把到了哪一个阵地作为阶段，注意到剩余的部队人数也是一个不可或缺的附加维度，那么我们就应该将其也加入到状态中。</p><p>设 $dp_{i, j}$ 表示到了第 i 个阵地，还剩下 j 部队人数的最大受益值。</p><p>注意到第一维可以直接原地滚动数组秒掉，注意循环顺序，别无中生部队啊。</p><p>怎样更好地确定向每个阵地派出多少部队呢？</p><p>发现每个阵地上驻守的人数是无序的，也就是说是不好处理的，既然如此我们就把每个阵地上的人数升序排序，这样一来如果我们当前的部队人数能够击败第 k 个对手的，之前的对手肯定也都是可以击败的，这样一来我们就可以较为方便地处理向每个阵地派出的部队人数了。</p><p>这样方便了转移也方便了设计方程。</p><p>因为我们使用了滚动数组，转移时一定要注意先枚举部队人数然后再枚举每一个对手。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            a[j][i] = <span class="built_in">rd</span>();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">sort</span>(a[i] + <span class="number">1</span>, a[i] + <span class="number">1</span> + s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; ++k)</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">2</span> * a[i][k])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j - a[i][k] * <span class="number">2</span> - <span class="number">1</span>] + k * i, dp[j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[m]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022.10.12 整理</title>
    <link href="/2022/10/14/2022.10.12%E6%95%B4%E7%90%86/"/>
    <url>/2022/10/14/2022.10.12%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基础的二分答案掌握尚不牢固（太丢人了）。</p><p>实际问题考虑不周全（更丢人了，甚至不和 0 取 $\max​$）。</p><p>码力还是不够强，斗地主没两个月就写不出来了（更进一步的丢人了）。</p><p>DP 还是弄不出来，还是得练。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><a href="https://www.luogu.com.cn/problem/P2678">P2678</a></p><p>这居然还不能全对着实丢大人了。</p><p>具体错误：</p><p>上来没有快速排序，石头的位置并<strong>不是有序</strong>的！</p><p>check 函数中判断石头挪走后，没有正确处理该和哪一个石头对比距离，应当是沿用之前的石头而不是上一个石头。</p><p>为什么上来要拿走当前的石头呢？因为拿走靠后一点的会给后面的留下更多选择的余地，这样比拿走上一个肯定更好一点，至少不会亏本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>, pos = <span class="number">0</span>, tot = <span class="number">0</span>; <span class="comment">// pos 为上一个石头的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(now &lt; n + <span class="number">1</span>) &#123;</span><br><span class="line">        ++now;</span><br><span class="line">        <span class="keyword">if</span>(a[now] - a[pos] &lt; x) ++tot; <span class="comment">// 不满足了，拿走当前的石头而保留上一个石头</span></span><br><span class="line">        <span class="keyword">else</span> pos = now; <span class="comment">// 如果满足条件那就看下一个距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tot &lt;= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2668">P2668</a></p><p>总而言之还是多写几遍吧，码力还是不够强。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= ans) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 搜索单顺子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">14</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == <span class="number">0</span>) len = <span class="number">0</span>; <span class="comment">// 顺子断掉了就把长度减掉</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++len; <span class="comment">// 累计长度</span></span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">5</span>) &#123; <span class="comment">// 满足发动条件</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) --a[j];</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) ++a[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>; <span class="comment">// 注意初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">14</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; <span class="number">2</span>) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">3</span>) &#123; <span class="comment">// 开双顺子</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) a[j] -= <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) a[j] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">14</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; <span class="number">3</span>) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ++len;</span><br><span class="line">            <span class="keyword">if</span>(len &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) a[j] -= <span class="number">3</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= i - len + <span class="number">1</span>; --j) a[j] += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">14</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt;= <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            a[i] -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">15</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt;= <span class="number">0</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                --a[j];</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                ++a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">14</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; <span class="number">2</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                a[j] -= <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                a[j] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i] += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i] -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">15</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; <span class="number">1</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                --a[j];</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                ++a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">14</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; <span class="number">2</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                a[j] -= <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                a[j] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] += <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            a[i] -= <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">15</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt;= <span class="number">0</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                --a[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">15</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[k] &lt;= <span class="number">0</span> || j == k) <span class="keyword">continue</span>;</span><br><span class="line">                    --a[k];</span><br><span class="line">                    <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                    ++a[k];</span><br><span class="line">                &#125;</span><br><span class="line">                ++a[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">14</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; <span class="number">2</span> || j == i) <span class="keyword">continue</span>;</span><br><span class="line">                a[j] -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">14</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[k] &lt; <span class="number">2</span> || k == j) <span class="keyword">continue</span>;</span><br><span class="line">                    a[k] -= <span class="number">2</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(x + <span class="number">1</span>);</span><br><span class="line">                    a[k] += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                a[j] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i] += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">15</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]) ++x;</span><br><span class="line"></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化 Trie</title>
    <link href="/2022/10/02/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%20Trie/"/>
    <url>/2022/10/02/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%20Trie/</url>
    
    <content type="html"><![CDATA[<p>依旧不给图。</p><p>可持久化一般解决的是区间查询类的问题。</p><p>可持久化 Trie 基本上都是按着 01 Trie 搞的。</p><p>怎么建一棵可持久化 Trie 呢？</p><p>考虑到：如果两个相邻版本的前缀相同的话，我们就从后一个版本当前节点往上一个版本的子节点上连一条边，这样我们就可以保证从每一个根节点出发都可以将所有的版本都过一遍。</p><p>先丢个例题：<a href="https://www.luogu.com.cn/problem/P4735">LuoguP4735</a></p><p>经过一番思考，我们令 s[i] 表示序列到 i 的前缀异或和。</p><p>令选择的节点为 p，那么我们无非要找到最大的 $s[p - 1]\ xor\ x\ xor\ s[n]$，那么我们就可以直接在 l-1 和 r-1 两个范围里边找到值就可以了。</p><p>令 $val = s[n] \operatorname{xor}\ x$。</p><p>如果只有 $p\ \le r - 1$ 的限制，我们直接用可持久化 01 trie，因为可持久化 01trie 上保存到的是 $\forall\ i \in [0, n], s[0-i]$  这些二进制数构成的 01trie，我们每次从 r-1 出发，优先找 val 当前位相反的就可以了。</p><p>如果加上 l-1 的限制，我们需要在节点上维护一些信息，设 end[p] 表示 Trie 的节点 p 是序列 s 中第几个二进制数的末尾节点（如果不是末尾就设成 -1）。lat[p] 表示以 p 为根节点的子树内最大的 end 值，如果遇上一个 lat[p] 比 l-1 小的那么我们就不能去了。</p><p>这样我们就解决了这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">600005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> trie[N * <span class="number">24</span>][<span class="number">2</span>], lat[N * <span class="number">24</span>];</span><br><span class="line"><span class="keyword">int</span> s[N], rt[N], n, m, tot;</span><br><span class="line"></span><br><span class="line"><span class="comment">// end 和 lat 可以合成一个数组用的呢</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> k, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123; <span class="comment">// i 是 s[i] 的编号，k 是第几位，p 是上一版本的根，q 是这一版本的根</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>) &#123; <span class="comment">// 如果插完了就返回</span></span><br><span class="line">        lat[q] = i; <span class="comment">// 将最大的值标记一下</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = (s[i] &gt;&gt; k) &amp; <span class="number">1</span>; <span class="comment">// 提取出当前位上的二进制数</span></span><br><span class="line">    <span class="keyword">if</span>(p) trie[q][c ^ <span class="number">1</span>] = trie[p][c ^ <span class="number">1</span>]; <span class="comment">// 如果 p 不为零的话</span></span><br><span class="line">                                           <span class="comment">// 我们尝试用 c^1 那个儿子去连过去</span></span><br><span class="line">                                           <span class="comment">// 因为 c 要用来向下存，而我们一共只有两个儿子</span></span><br><span class="line">                                           <span class="comment">// 在不考虑前后缀的情况下直接去赋值</span></span><br><span class="line">                                           <span class="comment">// 哪怕前缀不相等，节点编号也是 0（因为你并没有在上一个版本建这个节点）</span></span><br><span class="line">                                           <span class="comment">// 因此我们是不需要畏惧的！</span></span><br><span class="line">    trie[q][c] = ++tot; <span class="comment">// 新开节点</span></span><br><span class="line">    <span class="built_in">add</span>(i, k - <span class="number">1</span>, trie[p][c], trie[q][c]); <span class="comment">// 递归建下一个节点</span></span><br><span class="line">    lat[q] = <span class="built_in">max</span>(lat[trie[q][<span class="number">0</span>]], lat[trie[q][<span class="number">1</span>]]); <span class="comment">// 回溯的时候向上更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> val, <span class="keyword">int</span> k, <span class="keyword">int</span> lim)</span> </span>&#123; <span class="comment">// now 是到了哪个节点，k 是位数，lim 是 l - 1</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> s[lat[now]] ^ val; <span class="comment">// 如果查完了就只能返回当前子树中最大的值了</span></span><br><span class="line">    <span class="keyword">int</span> c = (val &gt;&gt; k) &amp; <span class="number">1</span>; <span class="comment">// 取出当前位</span></span><br><span class="line">    <span class="keyword">if</span>(lat[trie[now][c ^ <span class="number">1</span>]] &gt;= lim) <span class="keyword">return</span> <span class="built_in">ask</span>(trie[now][c ^ <span class="number">1</span>], val, k - <span class="number">1</span>, lim); <span class="comment">// 如果可以走的话，就走过去</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(trie[now][c], val, k - <span class="number">1</span>, lim); <span class="comment">// 否则就只能走另一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">    lat[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    rt[<span class="number">0</span>] = ++tot; <span class="comment">// 先弄个新节点出来</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, rt[<span class="number">0</span>]); <span class="comment">// 先把 0 插进去免掉分类讨论</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x;</span><br><span class="line">        rt[i] = ++tot;</span><br><span class="line">        <span class="built_in">add</span>(i, <span class="number">23</span>, rt[i - <span class="number">1</span>], rt[i]); <span class="comment">// 正经插入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">rd</span>();</span><br><span class="line">            rt[++n] = ++tot;</span><br><span class="line">            s[n] = s[n - <span class="number">1</span>] ^ x;</span><br><span class="line">            <span class="built_in">add</span>(n, <span class="number">23</span>, rt[n - <span class="number">1</span>], rt[n]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(rt[r - <span class="number">1</span>], x ^ s[n], <span class="number">23</span>, l - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对拍和调试</title>
    <link href="/2022/08/26/%E5%AF%B9%E6%8B%8D%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <url>/2022/08/26/%E5%AF%B9%E6%8B%8D%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对拍什么的大家都会，但我今天要来展示一下<strong>炒鸡对拍</strong>！</p><p>你们普通的对拍无非就是从蓝书上学来的，可是那样的生成数据并不是<strong>均匀的</strong>！</p><p>举个简单的例子：</p><p>你使用 <code>rand</code> 生成了两个集合：</p><p>$(1，2)$ 和 $(1, 2)$，它们相乘能组成的数只有：</p><p>$$(1, 2, 4)$$</p><p>也就是说你根本就没找出 3 这个数来！</p><p>如此一来，你生成的数并不均匀，所以这样对拍是可能锅掉的。</p><p>那么我们就要使用我们的……</p><h2 id="炒鸡对拍了！"><a href="#炒鸡对拍了！" class="headerlink" title="炒鸡对拍了！"></a>炒鸡对拍了！</h2><p>ps：以下方法仅使用于 C++ 版本不低于 C++11 的方法，不过现在 CCF 都给你 C++14 了……</p><h3 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a>生成数据</h3><p>首先我们要知道 STL 里边的一个新类型：</p><p><code>mt19937</code></p><p>这个到底是什么呢？因为探讨它和 OI 关系不大我们就不说了（好吧就是我不知道）。</p><p>然后我们这么写就会有一个生成函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>现在有了生成函数，我们去写一个生成一大堆均匀的数的东西吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform_int_distribution &lt;<span class="keyword">int</span>&gt; <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1e5</span>);</span><br></pre></td></tr></table></figure><p>什么你记不住？会读就会写。</p><p>然后我们完成了我们呢的生成方法，现在去按要求构造数据即可，比如我们构造个 A + B 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">range</span>(rd) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">range</span>(rd);</span><br></pre></td></tr></table></figure><p>整体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    uniform_int_distribution &lt;<span class="keyword">int</span>&gt; <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1e5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">range</span>(rd) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">range</span>(rd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们构造部分就解决了。</p><h3 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h3><p>首先我们需要去写一个一定正确的朴素程序，确保答案一定正确。</p><p>然后写一份我们自己的程序。</p><p>接下来我们要写一个检查程序。</p><p>我建议大家学学命令行，这里有奇效！</p><p>C++ 里有一个强大的函数叫 <code>system</code>，用这个东西可以用来在 C++ 里边执行我们的命令行。</p><p>我们在 C++ 中这么写便会执行一次编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;g++ sol.cpp -o sol -std=c++14&quot;</span>);</span><br></pre></td></tr></table></figure><p>解释一下，前面 4 个部分是用来编译你的文件的，后面这句是在 C++14 的标准下编译运行。如果你电脑上没有 C++14 那这句话是失效的，可以换个更高版本的 Dev 来解决问题。</p><p>如果你要吸氧，只需要在 <code>std=c++14</code> 后边加个空格再加个 <code>-O2</code> 即可，注意 O 要<strong>大写</strong>！<del>不然你就会跟 L_fire 一样每次编译都会跳出个 2.exe 来。</del></p><p>刚才那句编译命令编译好了我们自己的程序，那么让我们把要编译的都编译下吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">system</span>(<span class="string">&quot;g++ brute.cpp -o brute -std=c++14&quot;</span>)</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;g++ gen.cpp -o gen -std=c++14&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面两句编译了朴素程序和数据生成程序。</p><p>那么怎么对拍呢？我们要将生成的数据分别丢进两个程序里，观察它们的输出结果是否一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l; i &lt;= r; i++) &#123; <span class="comment">// 这里的 l，r 是你需要测定的数据范围</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;gen &gt; data.in&quot;</span>); <span class="comment">// 将生成的数据放入一个输入文件中</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;sol &lt; data.in &gt; data,out&quot;</span>); <span class="comment">// 将数据放入自己的程序中并将结果放入一个输出文件中</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;brute &lt; data.in &gt; data.ans&quot;</span>); <span class="comment">// 同上，由于文件不能重名我们改成 .ans</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc data.out data.ans&quot;</span>)) &#123; <span class="comment">// 比对两个输出结果，用 fc 命令进行对比，如果相同返回 0，不相同则返回 1</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;WA on#&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 找到了错误数据返回，然后退出程序去看错误的数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AC on#&quot;</span> &lt;&lt; i &lt;&lt; endl； <span class="comment">// 这里就是为了防止干等用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的 Code 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ sol.cpp -o sol -std=c++14&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ brute.cpp -o brute -std=c++14&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;g++ gen.cpp -o gen -std=c++14&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;gen &gt; data.in&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;sol &lt; data.in &gt; data.out&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;brute &lt; data.in &gt; data.ans&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc data.out data.ans&quot;</span>)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;WA on#&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;AC on#&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/234742zj.png"></p><p>现在我们的炒鸡对拍就完活了。</p><p>我们发现找出了错误的数据，明显要调试了，怎么调试呢？</p><p>调试大多离不开这几条：</p><ol><li>静态查错，按照你的代码逻辑看一遍，如果发现了奇妙的失误可以随手改掉。</li><li>输出语句非常好用</li><li>减少对调试工具的依赖，否则您将浪费时间。</li><li>尝试多构造一些边界数据，看看是否需要特殊判断。</li></ol><p>好了，快去愉快地对拍和调试吧！</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可持久化线段树</title>
    <link href="/2022/08/25/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <url>/2022/08/25/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人也没有学多长时间的可持久化数据结构，所以这篇博文多少会有些浅显，还请各位海涵并对学术性错误予以指正。</p><p>因为网络的原因我无法把评论区初始化掉，反正我的博客也没人看，而且这里边很多的 Md 和 $\LaTeX$ 都会出现一些奇妙的事情，所以我不会按照之前那种严格的规范来写博文了（避免 $\LaTeX$ 出锅）。</p><p>之前出过的锅我就不修了，反正洛谷博客上几乎也有备份，想看可以过去。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>”可持久化“的意思是我们在一个 DS 不断修改之后，我们可以找回每一个历史版本。</p><p>可持久化的 DS 多种多样，本文主要讲述可持久化线段树，又名主席树（也许未来还会更新？）。</p><p>请注意：搞学术的人并不认可<strong>主席树</strong>这个称呼，主席树只是 OI 选手们起的名字，<del>所以碰上了某个计算机科学家你跟他说一句：“您知道主席树吗？”，他只会说那不是可持久化线段树吗，哪来的主席树。</del></p><p>实现可持久化其实有一个暴力的办法：你不是要修改 $m$ 次吗？我直接给空间开个 $m$ 倍！</p><p>出题人：好，空间不够，您 MLE 了。</p><p><del>寄。</del></p><p>这个时候我们就要充分发扬人类智慧了。</p><p>我们分析一下，如果我们改了一个节点，有很多节点是不会被修改的，也就是说，修改了一个节点，不关很多节点的事。</p><p>那么我们只需要新建一些新的节点来表示更新后且被影响到的节点就可以了。</p><p>由于主席树的特性，我们采用动态开点线段树，也便于节省空间。</p><p>开新节点的时候我们只需要让总结点个数加 1 即可，访问子节点在结构体里定义，不要用父子二倍不然寄掉，存储根可以开个数组来干。</p><p>我们扔个例题吧：</p><p><a href="https://www.luogu.com.cn/problem/P3834">https://www.luogu.com.cn/problem/P3834</a></p><p>我们分析一下，我们要求出第 $k$ 小的数，那么我们可以对值域建一棵线段树，好吧值域有点大，我们给它离散化。接下来主席树上的节点要维护的就是从 1 到 $i$ 中数的个数。</p><p>可以发现一个事情，是不是类似前缀和？</p><p>没错，和前缀和非常相似！</p><p>那么我们就只需要通过将 $r$ 版本的值减去 $l$ 版本的值就可以得出这两个版本之间有多少个数。</p><p>查询第 $k$ 小，我们就只需要判断当前要查询的 $r$ 版本到 $l$ 版本之间的左儿子间的数的个数，如果个数比 $k$ 大，说明第 $k$ 小一定是在左儿子里，进入左儿子去找，否则我们将 $k$ 减去个数，然后去右儿子里边找。</p><p>当我们找到了一个叶子节点，说明我们已经找到了第 $k$ 小的数！</p><p>给 Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs;</span><br><span class="line">    <span class="keyword">int</span> dat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ls(x) t[x].ls</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rs(x) t[x].rs</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> dat(x) t[x].dat</span></span><br><span class="line"></span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[N], top;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++top;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ls</span>(p) = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    <span class="built_in">rs</span>(p) = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++top;</span><br><span class="line">    t[p] = t[now];</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        ++<span class="built_in">dat</span>(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">ls</span>(p) = <span class="built_in">change</span>(<span class="built_in">ls</span>(p), l, mid, x);</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid) <span class="built_in">rs</span>(p) = <span class="built_in">change</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, x);</span><br><span class="line">    <span class="built_in">dat</span>(p) = <span class="built_in">dat</span>(<span class="built_in">ls</span>(p)) + <span class="built_in">dat</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d %d\n&quot;,L,R,dat(rs(r)) - dat(rs(l)));</span></span><br><span class="line">    <span class="keyword">if</span>(L == R) <span class="keyword">return</span> L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rcnt = (<span class="built_in">dat</span>(<span class="built_in">rs</span>(r)) - <span class="built_in">dat</span>(<span class="built_in">rs</span>(l)));</span><br><span class="line">    <span class="keyword">int</span> mid = (R - L) / <span class="number">2</span> + L;</span><br><span class="line">    <span class="keyword">if</span>(rcnt &gt;= k) <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">rs</span>(l), <span class="built_in">rs</span>(r), mid + <span class="number">1</span>, R, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="built_in">ls</span>(l), <span class="built_in">ls</span>(r), L, mid, k - rcnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        n = <span class="built_in">rd</span>(), m = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(t));</span><br><span class="line">        top = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(b));</span><br><span class="line">        <span class="built_in">memset</span>(root, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(root));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">rd</span>(), b[i] = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n) - a - <span class="number">1</span>;</span><br><span class="line">        root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + num + <span class="number">1</span>, b[i]) - a;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;k&lt;&lt;&quot; &quot;;</span></span><br><span class="line">            root[i] = <span class="built_in">change</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, num, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="built_in">rd</span>(), r = <span class="built_in">rd</span>(), k = <span class="built_in">rd</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="built_in">ask</span>(root[l - <span class="number">1</span>], root[r], <span class="number">1</span>, num, k)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有向图上的Tarjan</title>
    <link href="/2022/08/25/Tarjan%20%E4%B8%8E%20DAG/"/>
    <url>/2022/08/25/Tarjan%20%E4%B8%8E%20DAG/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博文仅仅用来当作个人的学习笔记，创作的标准是让本人自己理解即可，不推荐当作读者的学习资料，如想学习 DAG 上的 Tarjan 算法建议上网搜索详细的资料。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>先约定好几个定义哈：</p><ol><li>强连通分量（scc）：表示在图上最大的一个子集，满足这个子集中所有点两两间可以相互连通。</li><li>流图：在一个 DAG 里，如果存在一个点 $\operatorname{start}$，从这个点出发可以到达所有点，称此图为流图。</li><li>搜索树：在一个流图上从 $\operatorname{start}$ 开始深度优先遍历时所有发生递归的边构成一颗以 $\operatorname{start}$ 为根的树，称其为流图的搜索树。</li><li>dfn：时间戳嘛。</li><li>后向边：搜索树上从一个后代指向前代的边。</li><li>前向边：搜索树上一个从前代指向后代的边。</li><li>树枝边：搜索树中的边。</li><li>横叉边：除上述以外所有的边。</li></ol><p>我们怎么求出强连通分量呢？</p><p>基本思路：对于每个点，尽量找到与它一起能构成环的所有节点。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>执行深度优先遍历，同时开一个栈，访问到 $x$ 时，栈中记录以下节点：</p><ol><li>搜索树上 $x$ 的祖先节点。</li><li>已经访问过，并且存在一条边到 $x$ 的祖先节点的边的节点。</li></ol><p>说白了，栈中的节点就是能与从 $x$ 出发的后向边和横叉边形成环的节点。</p><p>再引入一个追溯值：在以 $x$ 为根的子树中，$\operatorname{low_x}$  表示满足以下条件的节点的最小时间戳：</p><ol><li>该点存在栈中。</li><li>存在一条从以 $x$ 为根的子树中出发的有向边以该节点为终点。</li></ol><p>如果一个节点还未被访问，直接去访问， $\operatorname{low_x} = \min{\operatorname{low_x},\operatorname{low_y}}$。</p><p>如果被访问了，并且该节点还在栈中，$\operatorname{low_x} = \min{\operatorname{low_x}, \operatorname{dfn_y}}$。</p><p>如果找到一个 $\operatorname{low_x} = \operatorname{dfn_x}$ 的点，说明你找到了一个强连通分量，然后打上标记，记录一下就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++num;</span><br><span class="line">    st[++top] = u, is[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(is[v]) low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = st[top--], is[v] = <span class="literal">false</span>;</span><br><span class="line">            c[v] = cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span>(u != v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题不给了。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部分背包</title>
    <link href="/2022/08/25/%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%EF%BC%8C%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%8C%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%8C%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"/>
    <url>/2022/08/25/%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%EF%BC%8C%E8%AE%B0%E5%BF%86%E5%8C%96%EF%BC%8C%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%EF%BC%8C%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>UPD 2022.7.4：删除了 QQ 表情包（太智障了影响阅读者的心情）。一并删除了一些冗杂的话。</p><p>如果你实在是看不懂，那……要不回去复习复习基础的东西？</p><p>如果你没有 DP 基础，建议你去博文里边耐心地翻一翻我之前写过的 DP 入门——《什么是 DP》</p><h2 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h2><p>我们在写 DP 的时候，我们只需要记录结果就可以了，而不需要记录决策是什么，这个东西叫做<strong>无后效性</strong>。</p><p>这玩意在设计状态的时候比较重要，不然你的 DP 挂掉的几率……</p><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>来个例题：<a href="https://www.luogu.com.cn/problem/P1048">https://www.luogu.com.cn/problem/P1048</a>。</p><p>这道题异常的经典，是背包的不二之选。</p><p>根据上一篇博文的传统思路，我们肯定得先设计状态。</p><p>比如我们设计这样一个状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 dp[n] 表示用了前 n 个物品的最大价值。</span><br></pre></td></tr></table></figure><p>这样的状态是会挂掉的，因为前 $n$ 个物品占据了空间，会导致你有可能无法接着放物品，有后效性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 dp[k] 表示用了 k 的空间的最大价值。</span><br></pre></td></tr></table></figure><p>一样歇菜，你不知道前面的物品哪个用了哪个没用，还是不行。</p><p>那么怎么解决后效性的问题呢？</p><p>很简单，把产生后效性的东西扔进 $dp$ 里边就行了。</p><p>正确的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n][k] 表示用到前 n 个物品，占据了 k 的空间的最大价值。</span><br></pre></td></tr></table></figure><p>然后根据我们之前的方法，推出方程：</p><p>$dp[n][k] = \max(dp[n-1][k], dp[n-1][k-v[i]] + w[i])$</p><p>然后直接开始写，没啥好说的。</p><p>欸不不不，还有一点：</p><p>最终的答案，是在 $dp[n][…]$ 里边选一个最大的。</p><p>然后，你应该可以自己写出来了吧？</p><p>大水题，剪贴板。</p><p><a href="https://www.luogu.com.cn/paste/ohdv5old">https://www.luogu.com.cn/paste/ohdv5old</a></p><p>再来一个：<a href="https://www.luogu.com.cn/problem/P1049">https://www.luogu.com.cn/problem/P1049</a>。</p><p>这道题怎么办？</p><p>我们把它转化一下，既然求剩下的空间最小，我们就直接把<strong>能装下最多的空间</strong>用上面的方法求出来，然后用总空间一减就行。</p><p>这玩意又叫做：<strong>适配器原理</strong>。</p><p>适配器原理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在已知 A 问题的解决方式。</span><br><span class="line"></span><br><span class="line">给你一个 B 问题。</span><br><span class="line"></span><br><span class="line">你将它转换成 A 问题，用 A 问题的方式去求解。</span><br><span class="line"></span><br><span class="line">最后，将输出换成 B 问题的。</span><br></pre></td></tr></table></figure><p>过水，直接剪贴板。</p><p><a href="https://www.luogu.com.cn/paste/4efph4qp">https://www.luogu.com.cn/paste/4efph4qp</a></p><p>还有一个问题：<a href="https://www.luogu.com.cn/problem/P1060">https://www.luogu.com.cn/problem/P1060</a>。</p><p>这种题无非就是换换 $w$ 的算法而已，我相信你们都能自己写出来。</p><p>什么你实在不行？</p><p>好吧，给你自己去看：</p><p><a href="https://www.luogu.com.cn/paste/h4qikm3r">https://www.luogu.com.cn/paste/h4qikm3r</a></p><p>太水了，直接剪贴板待遇。</p><p>我们再来看看：</p><p>你是不是发现，那个 $n$，是不是只需要用一次？</p><p>以后每一次，是不是跟很久之前的 $n$ 一点关系都没有了？</p><p>那，我还存着你干什么，浪费空间让出题人卡爆我吗？</p><p>我们就要使用下一招：</p><h2 id="滚动数组！"><a href="#滚动数组！" class="headerlink" title="滚动数组！"></a>滚动数组！</h2><p>好了，怎么写呢？</p><p>挺简单，既然你只需要一层的，我新开个数组 $last$ 专门用来存上面的东西，然后再用个 <code>#include &lt;cstring&gt;</code> 里边的 <code>memcpy</code> 进行数组的复制就好了。</p><p>三个程序滚动数组版如下：</p><p><a href="https://www.luogu.com.cn/paste/jsr0vj8e">https://www.luogu.com.cn/paste/jsr0vj8e</a></p><p>太长了就直接扔剪贴板里边了，不过分吧？!</p><p>我们还可以采用另一种滚动数组的方法：<strong>原地滚动数组</strong>。</p><p>这一招就是换换循环顺序，然后你就可以直接过去了，连 $last$ 都不用开。</p><p>只放一个程序，不然我会累死。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 105</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, n;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">V = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">v[i] = <span class="built_in">read</span>(), w[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(j-v[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=V; i++) &#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>换个问题：如果每个物品都可以取无限次，那怎么办？</p><p><a href="https://www.luogu.com.cn/problem/P1616">https://www.luogu.com.cn/problem/P1616</a>。</p><p>也好说，我直接告诉你一个 trick：</p><p>原地滚动数组，循环方式变成正着来，因为现在无限次取用允许你正着更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, n;</span><br><span class="line"><span class="keyword">int</span> v[N], w[N];</span><br><span class="line">ll dp[<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">V = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">v[i] = <span class="built_in">read</span>(), w[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=v[i]; j&lt;=V; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(j-v[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=V; i++) &#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://www.luogu.com.cn/problem/P1776">https://www.luogu.com.cn/problem/P1776</a></p><p>现在第 $i$ 个物品只允许用 $a[i]$ 次，怎么办？</p><p><del>简单，叫出题人出来，武力解决。</del></p><p>简单点的思路：</p><p>弄出 $a[1]$ 个 1 号物品，$a[2]$ 个 2 号物品……</p><p>然后把它们统一地存在一个数组里边，用这个数组来跑 01 背包。</p><p>然后你会惊喜地发现，复杂度变成了 $(V * \sum{a[i]})$。</p><p><del>然后出题人跟你文斗，直接大数据送你 TLE，然后末影珍珠瞬移走，留下你一人抱着省二的证书痛哭失声。</del></p><p>那怎么办呢？</p><p>二进制分组！</p><p>问个问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>] 里面选一些数的和，是不是可以表示 <span class="number">12</span> 以内所有的数？</span><br></pre></td></tr></table></figure><p>proof：</p><p>[0, 7] 以内的数，肯定可以用 [1, 2, 4] 的子集和来表示，对吧？</p><p>[8, 12] 以内的数，先用个 5，接下来你要做的就是用 [1, 2, 4] 的子集和表示 [3, 7] 以内的数，这个问题刚才你已经解决过了。</p><p>把每种物品都分组，比如 14 个某物品可以分成 $[1, 2, 4, 7]$ 这些组。</p><p>分好这些组之后再扔给 01 背包去跑，直接输出结果。</p><p>物品总数就是：$\sum\log a[i]$。</p><p>其实不只是有二进制分组的优化方式，优先队列啥的也可以但是我不想写不然我会累死的。</p><p>然后是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> dp[N], w[N], v[N];</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=c; j&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">v[++pos] = j * b, w[pos] = j * a;</span><br><span class="line">c-=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c) &#123;</span><br><span class="line">v[++pos] = b * c, w[pos] = a * c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=pos; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=v[i]; j--) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">write</span>(dp[m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换换脑子，看个这个：</p><h2 id="记忆化方法"><a href="#记忆化方法" class="headerlink" title="记忆化方法"></a>记忆化方法</h2><p>还记得斐波那契数列吗？</p><p>$f(n) = f(n - 2) +f(n - 1)$</p><p>我们怎么去求呢？</p><p>来个比较暴力的程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;call_fib(%d)\n&quot;</span>, n);</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">2</span>) + <span class="built_in">fib</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">fib</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这恐怖的调用次数……感觉随随便便我们就完蛋了，不是吗？</p><p>主要的问题是，无数的东西被重复调用了，这就很难受。</p><p>但是，有一种方法可以拯救我们：</p><p>记忆化！</p><p>具体来说就是开俩数组，一个用来看看有没有来过，另一个存储这个地方的值。</p><p>然后如果来过，直接返回值。</p><p>好了，进阶版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[n]) &#123;</span><br><span class="line"><span class="keyword">return</span> sum[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;call_fib(%d)\n&quot;</span>, n);</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[n] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> sum[n] = <span class="built_in">fib</span>(n - <span class="number">2</span>) + <span class="built_in">fib</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">fib</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，看看这个题：<a href="https://www.luogu.com.cn/problem/P1541">https://www.luogu.com.cn/problem/P1541</a></p><p>如果你一看难度就被吓回去了……我建议你还是回来的好，别害怕嘛，这题很简单。</p><p>直接设计状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[pos][a][b][c][d] 表示走到 pos，用了 a 张 <span class="number">1</span>，b 张 <span class="number">2</span>，c 张 <span class="number">3</span>，d 张 <span class="number">4</span></span><br></pre></td></tr></table></figure><p>其中第一维可以滚掉，不然空间不行。</p><p>然后就简单了，你直接把所有牌扔进去，然后每次计算从 1 走到了哪里，加上答案，进行 dp，然后只要牌没打空就接着打。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 355</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 45</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[M][M][M][M];</span><br><span class="line"><span class="keyword">bool</span> vis[M][M][M][M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[N], p[<span class="number">5</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">w[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">p[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span> &amp;&amp; d == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> w[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[a][b][c][d]) &#123;</span><br><span class="line"><span class="keyword">return</span> sum[a][b][c][d];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = a + <span class="number">2</span> * b + <span class="number">3</span> * c + <span class="number">4</span> * d;</span><br><span class="line"><span class="keyword">if</span>(a) &#123;</span><br><span class="line">sum[a][b][c][d] = <span class="built_in">max</span>(sum[a][b][c][d], <span class="built_in">dp</span>(a - <span class="number">1</span>, b, c, d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b) &#123;</span><br><span class="line">sum[a][b][c][d] = <span class="built_in">max</span>(sum[a][b][c][d], <span class="built_in">dp</span>(a, b - <span class="number">1</span>, c, d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c) &#123;</span><br><span class="line">sum[a][b][c][d] = <span class="built_in">max</span>(sum[a][b][c][d], <span class="built_in">dp</span>(a, b, c - <span class="number">1</span>, d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(d) &#123;</span><br><span class="line">sum[a][b][c][d] = <span class="built_in">max</span>(sum[a][b][c][d], <span class="built_in">dp</span>(a, b, c, d - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum[a][b][c][d] += w[<span class="number">1</span>+pos];</span><br><span class="line">vis[a][b][c][d] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum[a][b][c][d];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">write</span>(<span class="built_in">dp</span>(p[<span class="number">1</span>], p[<span class="number">2</span>], p[<span class="number">3</span>], p[<span class="number">4</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;P1541.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;P1541.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2022/08/25/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/08/25/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>之前那个写的太垃圾了……今天我们重写一回。</p><p>中考结束之后就可以随心所欲地学 OI 了，先复习一下吧……</p><p>关于把所有人都取关了这件事……我被机惨了，我也懒得再关回来了。（喂我可不想点上百个关注啊！）</p><p>这个玩意写的时间比较长，复习一共开始没多久，写的慢一点对我也好……（行，就是我拖更）</p><p>行，正题开始。</p><p>温馨提示：本片博文含有大量的 $\LaTeX$，我尽量让大家看得舒服点，如果哪里排版炸掉了直接评论区告诉我我尽力改掉。</p><p><strong>如有学术错误，请毫不留情地在评论区指正，本人会仔细思考后采取措施，谢谢大家！</strong></p><p>我们先解释一下计算机中数的存储方式吧。</p><p>我们常说的与，或，非，异或这些逻辑运算的东西同样可以用于二进制的这些东西进行运算。至于这些东西怎么运算的……我觉得大家应该都会就不说了，反正随便个人都爆踩我这种蒟蒻。</p><p>在一个二进制整数中，我们定义其有 $n$ 位，最低位为 0，最高位为 $n-1$。</p><p>我们熟知的 <code>int</code> 和 <code>unsigned int</code> 都是 32 位整数（注意，C++ 里之规定这俩玩意位数不小于 16 位，但是多数现代计算机上都是拿 32 位算的，注意把这两个东西与 32 位整数相等是不严谨的）。</p><figure class="highlight plaintext"><figcaption><span>的最高位是符号位，0 表示非负数 1 表示负数，但是 ```unsigned int``` 没有这一位（下文我们统一将 ```unsigned int``` 简写为 ```uint```），也就是说，```uint``` 这东西把它存负数的那一堆全用来存了正数！</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在知道为什么 ```uint``` 比 ```int``` 在正数上能多存一倍了吧，人家二进制比你多一位！</span><br><span class="line"></span><br><span class="line">当然，只要别闲的拿它存负数什么都好说……</span><br><span class="line"></span><br><span class="line">还有个重要的东西叫**补码**。</span><br><span class="line"></span><br><span class="line">补码如下：</span><br><span class="line"></span><br><span class="line">```uint``` 的补码就是直接换成 32 位的二进制数。</span><br><span class="line"></span><br><span class="line">```int``` 当最高位为 $0$ 时直接看成 32 位的二进制数。</span><br><span class="line"></span><br><span class="line">如果你把 ```int``` 最高位给它取反，假如原二进制数是 $x$，它会变成 $-1-x$。</span><br><span class="line"></span><br><span class="line">不难发现，如果你把两个数加减运算的话，就等价于在二进制补码下进行**最高位不进位**的二进制加减。如果算术溢出的话会直接给你按 $2^&#123;32&#125;$ 给你取模，这也是为什么你会爆 ```int``` 的原因。直接给你加成负数（）</span><br><span class="line"></span><br><span class="line">现在问题来了，写代码的时候如果我们想要表示一个 ```int```，拿二进制写你得写个 32 位，直接累死。换十进制又表示不出补码的每一位（计算机可是拿这东西运算的喂！），因此我们用 8 位十六进制数来表示一个数。</span><br><span class="line"></span><br><span class="line">首先你要让计算机知道你写了个十六进制的数，你需要一个前缀：</span><br><span class="line"></span><br><span class="line">```0x```</span><br><span class="line"></span><br><span class="line">注意，这个玩意是声明十六进制用的，和数值**毫无关系**！</span><br><span class="line"></span><br><span class="line">接下来，用十六进制来表示你要的数（十六进制大家应该都会）。</span><br><span class="line"></span><br><span class="line">比如一个非常好用的数：</span><br><span class="line"></span><br><span class="line">```0x3f3f3f3f```</span><br><span class="line"></span><br><span class="line">这个值通常被我们拿来当无穷大来用，聪明的同学一定要问了：</span><br><span class="line"></span><br><span class="line">“那我们为什么不直接拿 ```0x7fffffff``` 呢？这东西是 ```int``` 能表示的最大整数！”</span><br><span class="line"></span><br><span class="line">很简单，随便一加就给你溢出了……你不会拿个负数当无穷大吧……</span><br><span class="line"></span><br><span class="line">而且，C++ 里边有个东西叫 ```memset```，它按**字节**给你赋值，也就是按 ```0x00~0xff``` 给你每一个**字节**赋值，当然你要是 ```0xff``` 会溢出的，而一个 ```int``` 占用 4 个**字节**，```memset``` 每次赋值一个**字节**，这也解释了为什么 ```memset``` 只能赋值出每 8 **位**都相同的 ```int```。（注意，位不等于字节！）</span><br><span class="line"></span><br><span class="line">因此你可以直接这样初始化一个数组：</span><br><span class="line"></span><br><span class="line">```memset(a, 0x3f, sizeof(a))```</span><br><span class="line"></span><br><span class="line">这样里边的每一个数都会变成：</span><br><span class="line"></span><br><span class="line">```0x3f3f3f3f```</span><br><span class="line"></span><br><span class="line">这是 ```0x3f3f3f3f``` 的一个好处，每八位都相同，还有一个实用的地方是把它乘以 2 也不会超过 ```int``` 能表示的最大整数，完美规避过算术溢出。</span><br><span class="line"></span><br><span class="line">是不是很简单呢？</span><br><span class="line"></span><br><span class="line">这样，你在贪心和 DP 的时候就快乐多了！</span><br><span class="line"></span><br><span class="line">好吧其实就算你没看懂上边这一堆……就当我教了你怎么初始化一个无穷大的数组得了，虽说授人以鱼不如授人以渔，但是死活学不会渔我也没救。</span><br><span class="line"></span><br><span class="line">现在，你大致弄明白了计算机中数的存储方式！</span><br><span class="line"></span><br><span class="line">下面我们说一说位移运算。</span><br><span class="line"></span><br><span class="line">左移：</span><br><span class="line"></span><br><span class="line">在二进制下将数整体向左移动，低位用 0 填上，高位越界之后舍弃掉。</span><br><span class="line"></span><br><span class="line">根据二进制数的表示方法，不难发现：</span><br><span class="line"></span><br><span class="line">$(n \ll 1) = 2n, (1 \ll n) = 2^n$</span><br><span class="line"></span><br><span class="line">为啥我加了括号……位运算不加括号真的容易暴毙……所以位运算就加括号吧，免得先判断再运算了。</span><br><span class="line"></span><br><span class="line">右移分为两种：算术右移与逻辑右移。</span><br><span class="line"></span><br><span class="line">算术右移：在二进制补码下把所有数字向右移，低位越界后舍弃，高位用**符号位**补上。</span><br><span class="line"></span><br><span class="line">不难发现，$(n \gg 1) = \left\lfloor\dfrac&#123;n&#125;&#123;2.0&#125;\right\rfloor$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有趣的是，“整数 / 2”这东西在 C++ 中是以除以二向零取整来实现的。</span><br><span class="line"></span><br><span class="line">逻辑右移：与算术右移的区别在于，最高位拿 0 来补充。</span><br><span class="line"></span><br><span class="line">C++ 中没有规定到底是用逻辑右移还是算术右移，这事编译器说了算。一般编译器都按算术右移来，所以我们一般默认右移是按算术右移操作。</span><br><span class="line"></span><br><span class="line">现在我们位运算学的差不多了，让我们来看看位运算能做些什么吧！</span><br><span class="line"></span><br><span class="line">### 快速幂</span><br><span class="line"></span><br><span class="line">我们有时需要求 $a$ 的 $b$ 次方的值（有时取个模），不难发现如果一个一个乘的话时间复杂度是 $\mathcal&#123;O&#125;(b)$，容易发现如果 $b$ 足够大我们是会 TLE 的，因此需要降低复杂度。</span><br><span class="line"></span><br><span class="line">我们都知道，每一个正整数都可以唯一表示为若干指数不重复的 2 的次幂的和，如果 $b$ 在二进制下有 $n$ 位，其中第 $i$ 位的数字为 $c_i$，可以证明：</span><br><span class="line"></span><br><span class="line">$b = c_&#123;n-1&#125;2^&#123;n-1&#125;+c_&#123;n-2&#125;2^&#123;n-2&#125;+\dots+c_02^0$</span><br><span class="line"></span><br><span class="line">然后你要给 $a$ 来个 $b$ 次方：</span><br><span class="line"></span><br><span class="line">$a^b = a^&#123;c_&#123;n-1&#125;2^&#123;n-1&#125;&#125; * a^&#123;c_&#123;n-2&#125;2^&#123;n-2&#125;&#125;*\dots*a^&#123;c_02^0&#125;$</span><br><span class="line"></span><br><span class="line">你还知道 $n = \left\lceil\log_2(b+1)\right\rceil$，你也知道一个基本的数学原理：</span><br><span class="line"></span><br><span class="line">$a^&#123;2^i&#125; = (a^&#123;2^&#123;i-1&#125;&#125;)^2$</span><br><span class="line"></span><br><span class="line">我们可以容易地通过 $n$ 次递推弄出每一个乘积项，当 $c_i = 1$ 时我们将该乘积项累积到答案中，将 $b\ \&amp;\ 1$ 可以得到最低位是否为 1，然后右移舍弃此位看下一个，这样我们通过遍历二进制下的数位得出了解，时间复杂度降为了 $\mathcal&#123;O&#125;(log\ b)$ （别问我为什么不写底数，换底公式自己去看）。</span><br><span class="line"></span><br><span class="line">那我们写写看看：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">int power(int a, int b) &#123;</span><br><span class="line">    int ans = 1; // 众所周知，乘法答案初始化成 1</span><br><span class="line">    while(b) &#123; // 遍历 b，直到把 b 右移完</span><br><span class="line">        if(b &amp; 1 == 1) ans = ans * a; // 若此位上数是 1，则此位需要累计入答案中（毕竟你乘个 1 跟没乘一样啊！）</span><br><span class="line">        a *= a; // 更新此时的 a</span><br><span class="line">        b &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：这里 $a$ 存储的是 $a^{2^i}$。</p><p><del>我都写了这么多注释了，你应该是能看懂的。</del></p><h3 id="64-位整数乘法"><a href="#64-位整数乘法" class="headerlink" title="64 位整数乘法"></a>64 位整数乘法</h3><p><a href="https://www.acwing.com/problem/content/92/">题目</a></p><p>什么？！64 位！还是乘法！这不得爆 <code> long long</code> ！</p><p>我知道你要大声地喊出：我要高精！</p><p>好吧，今天让你见识一下怎么不用高精来处理！</p><p>众所周知，<code>long long</code> 是 64 位的，能比 <code>int</code> 多存好多好多，但是这么大的数也是爆掉了，我们得换个思路。</p><p>有两种方法解决这个问题：</p><ol><li>还记得快速幂吗？</li></ol><p>我们依旧将 $b$ 拿二进制来表示，和之前一样就不写了，因此 $a * b = a^{c_{n-1}2^{n-1}} + a^{c_{n-2}2^{n-2}}+\dots+a^{c_02^0}$</p><p>注意一下这个式子和之前那个的区别！</p><p>我们也知道：$a * 2^i = (a * 2^{i-1}) * 2$，因此我们可以每乘一次都取模一下 $p$，不会超出 64 位整数的极限，这样这道题就跟之前没什么区别了。</p><p>写一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">work</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>, a = (a + a) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用除法性质</li></ol><p>容易知道：$a * b \mod p = a * b - \left\lfloor\dfrac{a * b}{p}\right\rfloor * p$，我们记录 $c = \left\lfloor\dfrac{a * b}{p}\right\rfloor$。</p><p>现在问题转化为：如何求 $c$ 呢？不妨想想用浮点数直接算 $c$，当精度撑不住了它会自动舍弃低位，因此小数点后面的东西是不精确的，利用这一特性可以向下取整。一种数据类型叫做 <code>long double</code>，十进制下它可以抗 18~19 位的数据，这样它就可以保下整数部分的精确值 $c$，然后强制换成 <code>unsigned long long</code> 型直接舍去小数点后东西。如果 $a * b$ 恰好被 $p$ 整除，处于精度误差，$c$ 可能比实际小 1，但是取模意义下不影响结果正确性。</p><p>现在有了 $c$，下面只需要算出 $a * b - c * p$ 就可以了，因为上式实际上就是 $a * b \mod p$，所以 $a * b - c * p \leqslant p &lt; 2^{64}$，所以我们直接给取一下 $2^{64}$ 的模，而 <code>unsigned long long</code> 的溢出恰好满足此要求，因此用 <code>unsigned long long</code> 算 $x = a * b$ 与 $y = c * p$，然后用 <code>long long</code> 计算 $(x \mod p - y \mod p) \mod 2^{64}$，大功告成，并且时间复杂度为 $\mathcal{O}(1)$，比上面的方法快得多。</p><p>写一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ld long double</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">work</span><span class="params">(ull a, ull b, ull p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p; <span class="comment">// 如果 a，b 一定在 0~p 之间，不用写这一步</span></span><br><span class="line">    ull c = (ld) a * b / p;</span><br><span class="line">    ull x = a * b, y = c * p;</span><br><span class="line">    ll ans = (ll)(x % p) - (ll)(y % p);</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>) ans += p; <span class="comment">// 防止弄出负数来</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制状态压缩"><a href="#二进制状态压缩" class="headerlink" title="二进制状态压缩"></a>二进制状态压缩</h3><p>我们一般简称状压。</p><p>这东西是指将一个长度为 $n$ 的 <code>bool</code> 数组用一个 $n$ 位二进制数来表示。利用下面位运算操作可以实现原 <code>bool</code> 数组中对应的下标元素的存取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(n &gt;&gt; k) &amp; 1 取出整数 n 在二进制下的第 k 位</span><br><span class="line">n &amp; ((1 &lt;&lt; k) -1) 取出整数 n 在二进制下的第 0~k-1 位</span><br><span class="line">n xor (1 &lt;&lt; k) 把整数 n 在二进制表示下的第 k 位取反</span><br><span class="line">n | (1 &lt;&lt; k) 把整数 n 在二进制表示下的第 k 位赋值为 1</span><br><span class="line"></span><br><span class="line">n &amp; (~(1 &lt;&lt; k)) 把整数 n 在二进制表示下的第 k 位赋值 0</span><br></pre></td></tr></table></figure><p>这种方法运算简便，并且节省了程序运行的空间和时间，如果 $n$ 不是很大，直接一个整数即可存储，反之可以用若干整数类型存储，或者直接 <code>bitset</code>。</p><p>来个例题：</p><p><a href="https://www.acwing.com/problem/content/93/">题目</a></p><p>这道题需要一点图论知识，如有需要请去我博客中慢慢翻出来吧。</p><p>容易想到朴素做法：枚举每个点的全排列，然后计算路径长取最小值，时间复杂度也就区区的 $\mathcal{O}(n * n!)$ 而已，如果你运气足够足够足够足够足够……（以下省略 $n$ 个足够）好，也是可以跑过去的！</p><p>但是我们并不是欧皇，那怎么办呢？</p><p>看到最值了，而且明显贪心不了，数论也没辙，只能 DP 了。</p><p>任意时刻，如果表示哪些点已经经过，哪些没有？我们很明显需要一个 $n$ 位进制数来解决问题，如果其第 $i$ 位为 1 则来过，反之没有来过。同时我们还需要知道现在所处的位置，因此可以设计状态：</p><p>$dp[i][j]$，表示在 $j$ 点上，其中第 $i$ 点是否被经过，此时的最短路径。</p><p>初始化一下，在起点时，$dp[1][0] = 0$ ，你只经过了 0 点，处于起点 0，此时路径长也为 0。其余值我们设为无穷大，我们的目标是：</p><p>$dp[(1 \ll n) - 1][n-1]$，即经过所有点后在终点时的最短路径。</p><p>可以找到状态转移方程：</p><p>$dp[i][j] = \min{dp[i\ \operatorname{xor}\ (1 \ll j)][k] + weight(k, j)}$，$0\leqslant k &lt; n$ 并且  $((i \gg j) &amp; 1) = 1$。</p><p>然后，我们写写看看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w[<span class="number">25</span>][<span class="number">25</span>])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;(<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">                    <span class="keyword">if</span>((i^<span class="number">1</span>&lt;&lt;j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i^<span class="number">1</span> &lt;&lt; j][k] + w[k][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个：<a href="https://www.acwing.com/problem/content/1000/">https://www.acwing.com/problem/content/1000/</a></p><p><del>当你们看到这题的时候心情估计是爆炸的。</del></p><p>没关系，我第一眼也是这样的。</p><p>考虑下位运算的特性：在二进制表示下不进位。</p><p>这就意味着：你最终的答案上二进制对应的位只和你选择的数的那一位有关！</p><p>既然如此，那我们直接去枚举每一位上填 1 好还是填 0 更好就可以了！</p><p>比如说，这一位要填 1，要满足两个条件：</p><ol><li>这一位填上 1 之后形成的数不能超过 $m$。</li><li>这一位填 1 要比填 0 好。</li></ol><p>如果不满足上述条件中的任何一个，我们只得填 0。</p><p>因此，我们可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;string, <span class="keyword">int</span>&gt; d[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> bit, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = d[i].second &gt;&gt; bit &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(d[i].first == <span class="string">&quot;AND&quot;</span>) now &amp;= x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d[i].first == <span class="string">&quot;OR&quot;</span>) now |= x;</span><br><span class="line"><span class="keyword">else</span> now ^= x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">d[i] = <span class="built_in">make_pair</span>(s, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> bit=<span class="number">29</span>; bit&gt;=<span class="number">0</span>; bit--) &#123;</span><br><span class="line"><span class="keyword">int</span> res0 = <span class="built_in">work</span>(bit, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> res1 = <span class="built_in">work</span>(bit, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(val + (<span class="number">1</span> &lt;&lt; bit) &lt;= m &amp;&amp; res0 &lt; res1)</span><br><span class="line">val += <span class="number">1</span> &lt;&lt; bit, ans += res1 &lt;&lt; bit;</span><br><span class="line"><span class="keyword">else</span> ans += res0 &lt;&lt; bit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成对变换"><a href="#成对变换" class="headerlink" title="成对变换"></a>成对变换</h3><p>不难发现：</p><p>对于任意整数 $n$：</p><p>$n$ 为偶数，则 $n \operatorname{xor} 1 = n + 1$，</p><p>$n$ 为奇数，则 $n \operatorname{xor} 1 = n - 1$。</p><p>为什么呢？因为在二进制下，一个数为奇数则最低位为 1，偶数则为 0。</p><p>所以，0 和 1，2 和 3， 4 和 5 ……构成…“成对变换”。</p><p>这个性质常被用于邻接表中边集的存储。</p><h3 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="lowbit 运算"></a>lowbit 运算</h3><p>我们定义：</p><p>$\operatorname{lowbit}(n)$ 表示非负整数 $n$ 在二进制表示下“最低位的 1 及其后边所有的 0” 构成的数值。</p><p>下面我们来推推 $\operatorname{lowbit}$ 的公式。</p><p>设最低位的 1 在 $k$ 位上</p><p>为了实现 $\operatorname{lowbit}$ 的运算，我们需要将 $n$ 取反，让 $k$ 此时为 0，然后给它加个 1，此时 $k$ 会变回 1，后边皆为 0。</p><p>上面这波取反加 1， $n$ 的第 $k+1$ 位到最高位与原来都相反，因此如果你来个这个操作：</p><p>$n\ &amp;\ (\sim n+1)$</p><p>这样，只会有第 $k$ 位是 1！</p><p>我们也知道，补码下将 $n$ 取反就会变成 $-1-n$</p><p>因此可以推出：</p><p>$\operatorname{lowbit}(n) = n\ &amp;\ (\sim n+1) = n\ &amp;\ (-n)$</p><p>那么 $\operatorname{lowbit}$ 能用来干什么呢？</p><p>我们可以用这个东西搭配 $\operatorname{Hash}$  来找出整数二进制表示下所有是 1 的位，时间复杂度与 1 的个数同级。</p><p>怎么做呢？</p><p>我们不断把 $n$ 赋值成 $n-\operatorname{lowbit}(n)$，一直到 $n = 0$。取出我们减去的这两个数，然后取它们的对数，然后可以得知 $n$ 的第几位是 1 了。</p><p>除此之外，$\operatorname{lowbit}$ 在树状数组中也是基础的运算。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列维护</title>
    <link href="/2022/08/25/%E5%BA%8F%E5%88%97%E7%BB%B4%E6%8A%A4/"/>
    <url>/2022/08/25/%E5%BA%8F%E5%88%97%E7%BB%B4%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<p>大坑，填起来比较辛苦，可能慢点。</p><p>一直没时间写，估计抽个集训的空就完成了。</p><p>比较毒瘤，食用前请确保基础数据结构掌握得差不多了，不然回去学完线性表再来（）</p><h2 id="乱入的优先队列"><a href="#乱入的优先队列" class="headerlink" title="乱入的优先队列"></a>乱入的优先队列</h2><p>一句话优先队列：往一个队列里边扔数，它自动给你排好序等你使用。</p><p>来一个十分简（bian）单（tai）的例题：</p><p>给定一个正数序列，求第 $k$ 小的子区间和。</p><p>$n \le 100000$</p><p>你跟我讲你不知道什么是子区间……</p><ul><li>子区间：连续的。</li><li>子序列：不连续的。</li></ul><p><del>扫盲工作有了大进展。</del></p><p><del>懵了没有？我早就料到了哈哈哈，你的招式不过如此！</del></p><p>请先克制住把我按在地上暴揍的心理，现在我把这题做法告诉你你的招式不就也上来了嘛。</p><p>首先分析题目性质：这个序列是<strong>正数</strong>。</p><p><strong>正数！正数！正数！</strong></p><p>也就是说，我们选一个长度小的区间的和肯定比长度大的区间的和要小。</p><p>最小的，一定就是形如 $[i, i]$ 这样的区间了。</p><p>（<del>都学到这了还不知道左闭右开和左闭右闭就去自闭吧</del>）。</p><p>记 $S[l, r]$ 为区间 $l \to r$ 的和。</p><p>你一定看得出：$S[l-1, r] \ge S[l, r]$， $S[l, r+1] \ge S[l, r]$。</p><p>我们掏出一个堆，先加进去 $[1, 1] \dots [n, n]$ 区间和。</p><p>找到一个最小的，然后从这个区间去像上面的左右拓展，找出第二小的区间，以此类推。</p><p>记住疯狂塞到堆里边。</p><p>最后记住，来个 $\mathtt{map}$ 和 $\mathtt{pair}$ 的联动，去重用，我们不能计算重复的区间。</p><p><del>你要代码？我都写这么清楚了居然还要代码！</del></p><p>好吧……既然你们仍然是一脸懵逼，我还是写一下吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这以上看不懂的回去复习第一部分吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个函数，不要问我为什么这么写，为什么可以写一样的</span></span><br><span class="line">    <span class="comment">// 鬼知道 C++ 的语法是森莫东东</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> sum) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">sum</span>(sum) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是重载了一个小根堆</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; a.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[N], k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是判重用的</span></span><br><span class="line">map &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; ds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背不过？会读就会写，欧耶</span></span><br><span class="line">priority_queue &lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码风格所迫……</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压入队列中，就像之前所说的那样</span></span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">Node</span>(i, i, a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码风格所迫……</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去找第 k 小的区间</span></span><br><span class="line">    <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">        <span class="comment">// 掏出来最小的</span></span><br><span class="line">        Node t = q.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 炸了它()</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们来过这里</span></span><br><span class="line">        <span class="keyword">if</span>(ds[pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; (t.l, t.r)]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 一定要给它续一条命！</span></span><br><span class="line">            <span class="comment">// 因为你要是再回去，你没有去找区间</span></span><br><span class="line">            <span class="comment">// 但是你 while 里边减了 k!</span></span><br><span class="line">            <span class="comment">// 所以要给它续命！</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记掉</span></span><br><span class="line">        ds[pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; (t.l, t.r)] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 你不能拓展出去</span></span><br><span class="line">        <span class="keyword">if</span>(t.l != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拓展之</span></span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(t.l - <span class="number">1</span>, t.r, t.sum + a[t.l - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        <span class="keyword">if</span>(t.r != n) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(t.l, t.r + <span class="number">1</span>, t.sum + a[t.r + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出你当前找到的区间</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, t.l, t.r, t.sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">inp</span>();</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><p>前缀和是什么？</p><p>一个序列，定义一个 $pre$ 数组，$pre[i]$ 为前 $i$ 个数的和，查询一个区间 $[l, r]$ 的时候，只需要 $pre[r] - pre[l - 1]$。</p><p>那这玩意如何计算呢？</p><p>异常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    pre[i] = pre[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维的东西……这东西是需要画图的，不过我觉得脑补应该可以吧……如果你非要看图（<del>我是不会画的</del>）就使用 gfs（google first search）。</p><p>差分又是什么呢？</p><p>差分数组的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[i] = a[i] - a[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>差分能干什么？</p><p>比如说：</p><p>有些东西直接统计起来，凉凉 TLE。</p><p>但是如果具有可减性，就可以使用差分来降低时间复杂度。</p><p>完美。</p><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>现在，我给定一个序列，需要您写出一个数据结构，支持以下操作：</p><ol><li>在第 $x$ 的位置上加上 $y$。</li><li>给出 $x$ 的前缀和。</li></ol><p>现在该如何是好呢？</p><p>如果您使用数组，您得先统计一遍前缀和，恭喜您，我修改了序列，于是您又去改一遍前缀和，然后我接着修改序列……</p><p>有常识的人都知道，TLE 在所难免了。</p><p>这种数据结构需要什么特点？</p><ul><li>树形结构的每个节点表示一个子集。</li><li>为了高效修改，每个序列上的位置只出现在少数个树形结构的节点上。</li><li>为了查询高效，对任意查询，可以通过少数个树形结构的节点拼出来。</li></ul><p>那么，有没有数据结构能来就我们一命？</p><p>树状数组可以满足您的要求。</p><p>树状数组是个什么东西？</p><p>剑鱼这东西实在毒瘤，于是我盗了 noip 的图，不过这是我氪了金的应该算是正常使用吧……</p><p>假设一个序列：$A[1] \sim A[8]$，用 $C[]$ 表示树状数组。</p><p>$C[x]$ 表示 $A[x - 2^k + 1, x]$ 这个区间的和，$k$ 是表示 $x$ 的二进制表示中第一位的 1。</p><p>蛤？</p><p>比如说，6，二进制表示 110。</p><p>则，k 就是 1。$2^k$ 就是 2。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v8ygf8il.png"></p><p>那么这玩意怎么求呢？难不成我还要去位运算？</p><p>恭喜您，答对了，给您加 10 分。</p><p>极其简单，一句话就可以求出 $2^k$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; -x)</span><br></pre></td></tr></table></figure><p>我们如何去构建一个树状数组？</p><p>根据我们之前说过的一堆东西，我们可以提前根据我们手中的数据数组去构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="built_in">lowbit</span>(i)+<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">c[i] = c[i] + t[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们查询一个前缀的和，可以用 $O(\log n)$ 个树状数组的节点拼起来，然后成功拼出这个前缀。</p><p>求法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i; i-=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        s += c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 $x$ 的位置上加上 $y$。</p><p>你会发现，在 $x$ 前面的结点是不会收到影响的，只有后面的结点才会被影响。</p><p>存储输入数据的数组好说，直接一加就行了，但是树状数组里边怎么办呢？</p><p>因为之前的和它半毛钱关系都没有，我们直接从 $x$ 和它以后的那些点进行修改就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    t[x] += y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;=n; i+=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        c[i] += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>树状数组就这么点东西了。</del></p><p><a href="https://www.luogu.com.cn/problem/P3374">P3374</a>，模板题。</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="keyword">int</span> n, t[N], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i; i-=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        ans += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    t[x] += y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x; i&lt;=n; i+=<span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        c[i] += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> c[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="built_in">lowbit</span>(i)+<span class="number">1</span>; j&lt;=i; j++) &#123;</span><br><span class="line">c[i] = c[i] + t[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">init</span>(c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span>(opt == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">modify</span>(x, y);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span>(y)-<span class="built_in">find</span>(x<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="/2022/08/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2022/08/25/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>之前那个实在是垃圾到不能再垃圾了……今天必须重写一份。</p><p>这个写的会稍微快一点，因为只有一个数据结构，而且也没有大量的 $\LaTeX$，对我也是相当的友好啊。</p><p><strong>如有学术问题，请毫不留情地在评论区予以指正。</strong></p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>线段树是一种基于二分思想的二叉树结构，用于在区间上进行信息统计。比起树状数组来用途更加广泛。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>关于线段树，你需要知道这些常识：</p><ol><li>线段树的每个节点都代表一个区间。</li><li>线段树具有唯一的根节点，代表的区间是整个统计范围（即题目中让你维护的序列）。</li><li>线段树的每个叶子节点代表的区间是一个长度为 1 的区间。</li><li>对于每个<strong>内部节点</strong> $[l, r]$，其左子节点为 $[l, mid]$，右子节点为 $[mid + 1, r]$，其中 $ mid =  \left\lfloor\ (l+r)/2 \right\rfloor$。</li></ol><p>我们可以发现，除了最后一层以外，线段树是一颗完全二叉树，所以我们可以用<strong>父子二倍</strong>的方法给其编号。树的深度为 $\mathcal{O}(\log N)$。</p><ol><li>根节点为 1</li><li>编号为 $x$ 的左子节点为 $x * 2$，右节点为 $x * 2 + 1$。</li></ol><p>如此一来，直接一个 <code>struct</code> 数组干上去，存储掉就可以了，多出的空间不必管它空着就行了，为了防止空间上的爆炸，请至少把保存线段树的数组开到 $N$ 的 4 倍（L_fire 奆佬说最好 8 倍或 16 倍，这个大家自己度德量力一下吧）</p><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p><del>要致富，先撸树。</del></p><p>我们建线段树就是为了维护序列，并且支持快速的查询与修改。给定一个长度为 $N$ 的序列 $A$，我们用每个叶子节点保存 $A$ 中的每个值。二叉树结构上下传递信息非常给力。下面让我们看看如何建树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r; <span class="comment">// 左端点，右端点 </span></span><br><span class="line"><span class="keyword">int</span> dat; <span class="comment">// 该区间维护的值 </span></span><br><span class="line">&#125;t[<span class="number">800005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">// p 代表当前的区间 </span></span><br><span class="line">t[p].l = l, t[p].r = r; <span class="comment">// 把它的区间弄进来 </span></span><br><span class="line"><span class="keyword">if</span>(l == r) &#123; <span class="comment">// 找到了叶子节点，赋值走人 </span></span><br><span class="line">t[p].dat = a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>; </span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span>, l, mid); <span class="comment">// 左子树 </span></span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r); <span class="comment">// 右子树 </span></span><br><span class="line">t[p].dat = <span class="built_in">max</span>(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat); <span class="comment">// 更新答案 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>我们知道，如果序列上随便改个点，那么这一堆区间的最值都得跟着遭殃，我们亟需快速的方法进行修改。</p><p>不过不用胆怯，线段树直接爆踩这些东西。</p><p>线段树中，根节点是任何操作的入口，我们从根节点一路递归到修改对应的叶子节点上，修改它的值，然后一路往上修改这个叶子节点的所有父亲节点，这样就完成了修改，时间复杂度为 $\mathcal{O}(\log N)$。</p><p>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">// p 是当前所在区间，x 是修改的位置，v 是修改的值 </span></span><br><span class="line"><span class="keyword">if</span>(t[p].l == t[p].r) &#123; <span class="comment">// 找到了 x 的叶子节点，我们直接修改 </span></span><br><span class="line">t[p].dat = v;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(p * <span class="number">2</span>, x, v); <span class="comment">// 如果修改的地方在左子树，去找那个节点 </span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, x, v); <span class="comment">// 反之则去右子树找 </span></span><br><span class="line"></span><br><span class="line">t[p].dat = <span class="built_in">max</span>(t[p * <span class="number">2</span>].dat, t[p * <span class="number">2</span> + <span class="number">1</span>].dat); <span class="comment">// 更新值 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>这种问题一般问我们在一个区间中的最大值，我们利用线段树去解决此问题。</p><p>从根节点开始，我们执行以下递归过程：</p><ol><li>如果要求区间完全覆盖掉了当前的区间，我们直接回溯并把此区间当做候选答案</li><li>若左子节点与要求区间有重合，我们递归访问左子节点</li><li>右子节点与要求区间有重合，我们递归访问右子节点</li></ol><p>上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= t[p].l &amp;&amp; t[p].r &lt;= r) <span class="comment">// 恰好覆盖 </span></span><br><span class="line"><span class="keyword">return</span> t[p].dat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> val = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) val = <span class="built_in">max</span>(val, <span class="built_in">ask</span>(p * <span class="number">2</span>, l, r)); <span class="comment">// 更新值 </span></span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) val = <span class="built_in">max</span>(val, <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, l ,r)); <span class="comment">// 更新值 </span></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的查询过程会将要求区间分成 $\log N$ 个节点，取最值作为答案。</p><p>$$现在，我们成功地写出了一个线段树！$$</p><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>我们知道，很多题目都是要求我们进行区间修改的，这种时候如果沿用之前的修改方式时间复杂度会变成 $\mathcal{O}(n)$，这超出了我们的承受范围。</p><p>考虑一个问题，如果我们修改了该节点和其所有的子树节点，然而这些子树上的节点<strong>一个也没有用过</strong>，那我们修改它们就是徒劳的。</p><p>注意到这个性质之后，我们可以在该节点上打一个标记，修改该节点后并不对其子树上的节点开刀，等用到这个子节点的时候我们再向下给它更新值去，这个标记我们称其为延时标记。</p><p>换言之，延时标记的意义为：该节点被修改过，但其子节点未被修改。</p><p>在后续的操作中，如果需要子树上的节点的话，我们从 $p$ 开始递归，检查其是否带有标记，如果有的话就更新两个子节点，然后给子节点打上标记，最后清除 $p$ 的标记。</p><p>我们可以发现，每条查询与修改皆变为了 $\mathcal{O}(\log n)$。</p><p>好的，来几个例题吧！</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.acwing.com/problem/content/description/244/">https://www.acwing.com/problem/content/description/244/</a>。</p><p>这是个线段树的裸题，我们直接上代码，我相信你们能看懂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(x) t[x].add</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">ll sum, add;</span><br><span class="line">&#125;t[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line"><span class="built_in">sum</span>(p) = a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spr</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">add</span>(p)) &#123;</span><br><span class="line"><span class="built_in">sum</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span>) - <span class="built_in">l</span>(p * <span class="number">2</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span> + <span class="number">1</span>) - <span class="built_in">l</span>(p * <span class="number">2</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">add</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p);</span><br><span class="line"><span class="built_in">add</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p);</span><br><span class="line"><span class="built_in">add</span>(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) &#123;</span><br><span class="line"><span class="built_in">sum</span>(p) += (ll)d * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">add</span>(p) += d;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">spr</span>(p);</span><br><span class="line"><span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) <span class="built_in">change</span>(p * <span class="number">2</span>, l, r, d);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, d);</span><br><span class="line"><span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line"><span class="built_in">spr</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">ll val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) val += <span class="built_in">ask</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) val += <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> l, r, d;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p><p>跟上边这题一样，自己改改去就行了。</p><p><a href="https://www.acwing.com/problem/content/246/">https://www.acwing.com/problem/content/246/</a></p><p>这道题是个单点修改的，不过要注意最大连续子段和的求法：</p><p>这里我们除了 $l, r$ 以外再维护 4 个信息：</p><p>区间和 $\operatorname{sum}$，区间最大连续子段和 $\operatorname{dat}$，紧靠左端的最大连续子段和 $\operatorname{lmax}$，紧靠右端的最大连续子段和 $\operatorname{rmax}$。</p><p>如何求 $\operatorname{dat}$ 呢？首先我们需要两个子节点的区间和来更新此节点的区间和，随后更新紧靠左端与紧靠右端的最大连续子段和，更新方式较为类似，这里介绍一种方法另一种大家自己依葫芦画瓢就行了：</p><p>更新紧靠左端的最大连续子段和：从左子树的紧靠左端的最大连续子段和与左子树的紧靠右端的最大连续子段和加上右子树的区间和中取最大值。</p><p>最后，我们更新好了这两个东西之后我们就用左右子树的最大连续子段和与左子树的紧靠右端的最大连续子段和加上右子树紧靠左端的最大连续子段和这三个数中取最大值，就是我们要的最大连续子段和了。</p><p>贴代码（这份代码是我和 L_fire 大佬一起写的，所以码风不大一样，不过大部分是我自己编写的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> sum, lmax, rmax, dat;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">&#125;t[<span class="number">6000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m,inf=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">t[p].l = l, t[p].r = r;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">t[p].sum = a[l];</span><br><span class="line">t[p].lmax = a[l];</span><br><span class="line">t[p].rmax = a[l];</span><br><span class="line">t[p].dat = a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">t[p].sum = t[p * <span class="number">2</span>].sum + t[p * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">t[p].lmax = <span class="built_in">max</span>(t[p * <span class="number">2</span>].lmax, t[p * <span class="number">2</span>].sum + t[p * <span class="number">2</span> + <span class="number">1</span>].lmax);</span><br><span class="line">t[p].rmax = <span class="built_in">max</span>(t[p * <span class="number">2</span> + <span class="number">1</span>].rmax, t[p * <span class="number">2</span> + <span class="number">1</span>].sum + t[p * <span class="number">2</span>].rmax);</span><br><span class="line">t[p].dat = <span class="built_in">max</span>(t[p * <span class="number">2</span>].dat, <span class="built_in">max</span>(t[p * <span class="number">2</span> + <span class="number">1</span>].dat, t[p * <span class="number">2</span>].rmax + t[p * <span class="number">2</span> + <span class="number">1</span>].lmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[p].l == t[p].r) &#123;</span><br><span class="line">t[p].sum = y;</span><br><span class="line">t[p].lmax = y;</span><br><span class="line">t[p].rmax = y;</span><br><span class="line">t[p].dat = y;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (t[p].l + t[p].r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) <span class="built_in">change</span>(p * <span class="number">2</span>, x, y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, x, y);</span><br><span class="line">t[p].sum = t[p * <span class="number">2</span>].sum + t[p * <span class="number">2</span> + <span class="number">1</span>].sum;</span><br><span class="line">t[p].lmax = <span class="built_in">max</span>(t[p * <span class="number">2</span>].lmax, t[p * <span class="number">2</span>].sum + t[p * <span class="number">2</span> + <span class="number">1</span>].lmax);</span><br><span class="line">t[p].rmax = <span class="built_in">max</span>(t[p * <span class="number">2</span> + <span class="number">1</span>].rmax, t[p * <span class="number">2</span> + <span class="number">1</span>].sum + t[p * <span class="number">2</span>].rmax);</span><br><span class="line">t[p].dat = <span class="built_in">max</span>(t[p * <span class="number">2</span>].dat, <span class="built_in">max</span>(t[p * <span class="number">2</span> + <span class="number">1</span>].dat, t[p * <span class="number">2</span>].rmax + t[p * <span class="number">2</span> + <span class="number">1</span>].lmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;r&gt;=t[p].r) <span class="keyword">return</span> t[p];</span><br><span class="line"><span class="keyword">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r &lt;= mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Node t1 = <span class="built_in">ask</span>(p * <span class="number">2</span>, l, mid), t2 = <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r), t3;</span><br><span class="line">t3.l = l, t3.r = r;</span><br><span class="line">t3.sum = t1.sum + t2.sum;</span><br><span class="line">t3.lmax = <span class="built_in">max</span>(t1.lmax, t1.sum + t2.lmax);</span><br><span class="line">t3.rmax = <span class="built_in">max</span>(t2.rmax, t2.sum + t1.rmax);</span><br><span class="line">t3.dat = <span class="built_in">max</span>(t1.dat, <span class="built_in">max</span>(t2.dat, t1.rmax + t2.lmax));</span><br><span class="line"><span class="keyword">return</span> t3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> k, x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(<span class="number">1</span>, x, y).dat);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>, x, y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3373">https://www.luogu.com.cn/problem/P3373</a></p><p>我们发现这个题要维护两种标记，乘法与加法，也就是说我们需要两个传递函数。</p><p>不过我们需要注意到一个东西：这里更新乘法标记的时候也要更新加法标记，但是更新加法标记的时候不能更新乘法标记。</p><p>我觉得都看了这么多代码了，自己写一次应该可以吧。</p><p><a href="https://www.luogu.com.cn/problem/P4588">https://www.luogu.com.cn/problem/P4588</a></p><p>这道题第一眼看上去根本不知道在干些什么……分析分析看。</p><p>我们看的出来，现在的问题是如何快速地找到第 $pos$ 次操作所乘的数，那么明显我们要维护所有的 $m$。</p><p>不妨转换思想，用离线的方式来考虑问题（好吧其实是半离线），当遇上一个要求乘法操作的时候我们就将其存入一个数组中，然后拿这个数组来建树，（并记录下这个数对应的次数），每次出现一个除法操作我们就去二分查找次数从而确定它的数值，然后将这个数值修改成 1（想想看，为什么？）。</p><p>为什么说是半离线操作呢？因为我们发现每次的输出都是有要求的，即我们需要以当前的元素个数进行乘法处理，乘完之后我们直接输出根节点的元素解决问题，因此掌控好合适的区间是必要的，这就是我们需要一个变量来控制区间的原因。</p><p>行了行了上代码（这份也是我和 L_fire 一起编写的，码风差异请自行忽略）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) t[x].sum</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">ll add, sum;</span><br><span class="line">&#125;t[<span class="number">800005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> op,m;</span><br><span class="line">&#125;c[<span class="number">1000005</span>];</span><br><span class="line">ll mod;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>], b[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line"><span class="built_in">sum</span>(p) = a[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span>, l ,mid);</span><br><span class="line"><span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) * <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line"><span class="built_in">sum</span>(p) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) <span class="built_in">change</span>(p * <span class="number">2</span>, l, r);</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) <span class="built_in">change</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) * <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) / <span class="number">2</span>;</span><br><span class="line">ll val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r &gt; mid) val = val * <span class="built_in">ask</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r) % mod;</span><br><span class="line"><span class="keyword">if</span>(l &lt;= mid) val = val * <span class="built_in">ask</span>(p * <span class="number">2</span>, l, r) % mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line">cin&gt;&gt;q&gt;&gt;mod;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c[i].op&gt;&gt;c[i].m;</span><br><span class="line"><span class="keyword">if</span>(c[i].op==<span class="number">1</span>) &#123;</span><br><span class="line">a[++cnt] = c[i].m;</span><br><span class="line">b[cnt] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i].op == <span class="number">1</span>) top++;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + cnt, c[i].m) - b;</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>, num, num);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, top) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>top sort</title>
    <link href="/2022/08/25/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/08/25/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>UPD 2022/7/4：删除了一大堆没有意义的内容。</p><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>拓扑排序是什么？</p><p>就是在一个 DAG 上边，将所有的点排成一个线性的序列，使得每个点的起点都在终点前边。</p><p>那它可以用来干什么呢？</p><p>这可以用来处理一些层次关系，就是如果你想做事件 $A$，必先处理完事件 $B$，类似这样的关系。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们用 BFS 来处理拓扑排序。</p><p>我们拿这张图举例：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rl0430ej.png"></p><p>根据所有的起点都要在终点前边这句话，我们首先要找到入度为 0 的点进行我们的拓扑排序。</p><p>这张图的拓扑序也就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>其中，2 和 3 的位置可以调换。</p><p>那么，我们就可以给这个图来个 BFS，每次看看这个点入度是否为 0，然后先把入度为 0 的点扔进队列。接下来输出这个点，然后开始遍历这个点所到达的每一个点，将到达的点的入度减一（即：删去这条边），然后看一看到达的点的入度是否为 0，如果为 0 就压进队列，然后重复上面的过程直到队列为空。</p><p>这边强烈建议看着思路写出来，不要看接下来的代码，因为这就是最简单的拓扑排序的模板，写出来是很简单的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, in[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> y, nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ltp, lk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">e[++ltp] = (Graph)&#123;v, lk[u]&#125;;</span><br><span class="line">lk[u] = ltp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">top_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">write</span>(p);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lk[p]; i; i=e[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> y=e[i].y;</span><br><span class="line">in[y]--;</span><br><span class="line"><span class="keyword">if</span>(!in[y]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">insert</span>(u, v);</span><br><span class="line">in[v]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!in[i]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">top_sort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;top_sort.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;top_sort.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用拓扑排序判环"><a href="#使用拓扑排序判环" class="headerlink" title="使用拓扑排序判环"></a>使用拓扑排序判环</h2><p>如果给你的图不是个 DAG，那怎么办呢?</p><p>既然他有环，我们就得看看它是不是存在环，如果存在我们就得反映出来。</p><p>来个图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ivhaf36y.png"></p><p>其实也简单，你会发现 2 3 4 组成的环会把一些点重复弹出队列。</p><p>根据这个性质，你每次把一个数弹出队列的时候就把弹出次数自增，最后看看是不是和结点数一样就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, in[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> y, nxt;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ltp, lk[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> cnt, pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">w = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x = x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = -x;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="built_in">write</span>(x / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">e[++ltp] = (Graph)&#123;v, lk[u]&#125;;</span><br><span class="line">lk[u] = ltp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">top_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">ans[++pos] = p;</span><br><span class="line">cnt++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=lk[p]; i; i=e[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> y=e[i].y;</span><br><span class="line">in[y]--;</span><br><span class="line"><span class="keyword">if</span>(!in[y]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">insert</span>(u, v);</span><br><span class="line">in[v]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!in[i]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">top_sort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=pos; i++) &#123;</span><br><span class="line"><span class="built_in">write</span>(ans[i]);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Leave me alone&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;top_sort.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;top_sort.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="built_in">inp</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓扑排序的时间复杂度是 $O(n +m)$，挺快的。</p>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树链剖分</title>
    <link href="/2022/08/25/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <url>/2022/08/25/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>树链剖分有什么用呢？目前我唯一已知的用途是支持动态修改树以及求 LCA（常数还小点），<del>还有将你的代码量加上 1 kib。</del></p><p>树链剖分将树分成若干链的形式，这样可以维护路径上的信息。也就是将一个树剖分成一堆序列。树链剖分分为重链剖分，长链剖分，实链剖分（用于 LCT 的剖分）。</p><p>大多数情况下，树链剖分一般指重链剖分。</p><p>重链剖分将树上任意一条路径划分成不超过 $\log(n)$ 条连续的链，都是自底向上的链，还能保证 DFS 序连续，这样可以用一些维护序列的东西来维护路径上的信息（such as 线段树）。</p><p><del>（线段树就不短了，再加一个树剖，我感觉不熟练的话就可以提前在聊天框里发 gg 了这样还能加 5 rp 值）。</del></p><p>不过写完后发现树剖也不是很长，主要长度感觉是线段树贡献的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>给一些定义：</p><ol><li>重子节点：表示其子节点中子树最大的节点，有多个的话取其一。</li><li>轻子节点：表示其子节点中除了重子节点以外的所有节点。</li><li>重边：从一个节点到重子节点的边为重边。</li><li>轻边：到轻子节点的边。</li><li>重链：若干条首尾衔接的重边构成的，落单的节点也当作重链。</li></ol><p>树剖的实现分为两个 DFS 的过程，第一遍求出每个节点的父亲，节点的深度，节点子树的个数，重儿子，第二遍求出节点所在重链的顶部节点，DFS 序，和 DFS 序所对应的节点编号。</p><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    son[u] = <span class="number">-1</span>; <span class="comment">// 一开始不确定重儿子是谁</span></span><br><span class="line">    siz[u] = <span class="number">1</span>; <span class="comment">// 子树大小至少为 1，因为本身也算在字数里</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!dep[v]) &#123; <span class="comment">// 如果没遍历过这个节点</span></span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>; <span class="comment">// 深度</span></span><br><span class="line">            fa[v] = u; <span class="comment">// 记录父亲</span></span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v]; <span class="comment">// 统计子树大小</span></span><br><span class="line">            <span class="keyword">if</span>(son[u] == <span class="number">-1</span> || siz[v] &gt; siz[son[u]]) <span class="comment">// 更新重儿子</span></span><br><span class="line">                son[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// t 指当前重链的顶部节点</span></span><br><span class="line">    top[u] = t; <span class="comment">// 记录节点</span></span><br><span class="line">    ++cnt;</span><br><span class="line">    dfn[u] = cnt; <span class="comment">// DFS 序</span></span><br><span class="line">    rk[cnt] = u; <span class="comment">// 记录 DFS 序对应的节点</span></span><br><span class="line">    <span class="keyword">if</span>(son[u] == <span class="number">-1</span>) <span class="keyword">return</span> ; <span class="comment">// 叶子节点就返回</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t); <span class="comment">// 优先遍历重儿子，保证同一条链上的 DFS 序连续</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lk[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v != son[u] &amp;&amp; v != fa[u]) <span class="comment">// 走到了一个轻边，当然换了一条链</span></span><br><span class="line">            <span class="built_in">dfs2</span>(v, v); <span class="comment">// 所以链的顶部节点就更换成了它自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现每次向下走一条轻边，所在子树大小就至少除以 2。</p><p>怎么用树剖求 LCA 呢？</p><p>不断向上跳重链，跳到同一条重链上时，深度较小的节点便是 LCA。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u] != top[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]] &gt; dep[top[v]]) u = fa[top[u]];</span><br><span class="line">        <span class="keyword">else</span> v = fa[top[v]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dep[u] &gt; dep[v] ? v : u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Treap</title>
    <link href="/2022/08/25/Treap/"/>
    <url>/2022/08/25/Treap/</url>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>请先学会 BST，如果没有弄会 BST 的话建议去<a href="https://www.luogu.com.cn/blog/Minecraft886/post-bst">这里</a>。 </p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>书接上回，我们在 BST 的结尾留下了一个问题：如何将 BST 弄平衡？</p><p>答案是：弄成一颗平衡二叉搜索树！以后我们就将其简称为平衡树。</p><p>平衡树有很多类型，今天我们介绍一种入门级的平衡树——Treap。</p><p><del>写一天博文都快累死了。</del></p><h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Treap 是 Tree + Heap 的合成词。</p><p>我们都知道，满足 BST 性质且中序遍历为相同序列的二叉查找树并不唯一，也就是不管这些树内部是什么样的，它们都是等价的，所以我们可以在满足 BST 性质的前提下对这个 BST 做一些事情，改变它的形态，使每个节点的左右子树达到平衡，这样整棵树的深度都维持在 $\mathcal{O}(\log n)$，这样时间复杂度就好说了。</p><p>基本上改变 BST 的基本操作就是<strong>旋转</strong>，最基本的旋转就是“单旋转”，单旋转又分为左旋和右旋，这里的左旋右旋操作都统一对“旋转前处于父节点位置”的节点执行左右旋操作。</p><p>我们拿右旋来举例吧：（图我不想找了，大家上网找张图看吧）</p><p>初始情况下，$x$ 是  $y$ 的左子节点，A 和 B 分别是 $x$ 的左右子树，C 是 $y$ 的右子树。</p><p>$x$ 要变成 $y$ 的父亲，因为 $x$ 的关键值比 $y$ 的小，因此 $y$ 要作为 $x$ 的右子节点，那么 B 就没有位置了，因此要把 B 设为 $y$ 的左子节点，A 的位置并没有被占据，继续当 $x$ 的左子树就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = a[p].l;</span><br><span class="line">    a[p].l = a[q].r, a[q].r = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = a[p].r;</span><br><span class="line">    a[p].r = a[q].l, a[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左旋也是一样的道理。</p><p>合理的旋转可以让 BST 变得很平衡，怎样才能干出合理的旋转呢？</p><p>我们发现，在随机数据下 BST 是趋近平衡的，Treap 的思想就是利用“随机”来创造平衡，旋转的时候必须维持 BST 性质，因此我们就只好用堆性质来搞了。在插入新节点的时候，随机生成一个额外的权值，如果某个节点不满足大根堆性质的话，就旋转。</p><p>删除的时候，因为 Treap 支持旋转，为了避免节点信息更新，堆性质维护等复杂问题，我们找到要删除的节点之后把它向下旋转成叶子节点，然后直接删除。</p><p>Treap 的检查，插入，求前驱后继和删除节点的时间复杂度都是 $\mathcal{O}(\log n)$ 的。</p><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p>有生之年终于来例题了啊！</p><p><a href="https://www.luogu.com.cn/problem/P3369">P3369</a></p><p>有相同的值啊，我们给每个节点加一个 $cnt$，表示这个节点上的值有多少个，又要查询排名，我们可以加一个 $siz$，记录以该节点为根的子树中所有节点的 $cnt$ 和，如果不存在重复的 $cnt$ 的话，$siz$ 就是子树大小。记住插入和删除以及旋转的时候修改下 $siz$ 就好辣！</p><p>我不想写注释了，不懂直接问吧，我已经学了整整一天平衡树了不想思考了:(。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">int</span> val, dat;</span><br><span class="line">    <span class="keyword">int</span> cnt, siz;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, rt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    a[++tot].val = val;</span><br><span class="line">    a[tot].dat = <span class="built_in">rand</span>();</span><br><span class="line">    a[tot].cnt = a[tot].siz = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    a[p].siz = a[a[p].l].siz + a[a[p].r].siz + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* int get(int p, int val) &#123;</span></span><br><span class="line"><span class="comment">    if(p == 0) return 0;</span></span><br><span class="line"><span class="comment">    if(val == a[p].val) return p;</span></span><br><span class="line"><span class="comment">    return val &lt; a[p].val ? get(a[p].l, val) : get(a[p].r, val);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rk</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) <span class="keyword">return</span> a[a[p].l].siz + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; a[p].val) <span class="keyword">return</span> <span class="built_in">get_rk</span>(a[p].l, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_rk</span>(a[p].r, val) + a[a[p].l].siz + a[p].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">if</span>(a[a[p].l].siz &gt;= rk) <span class="keyword">return</span> <span class="built_in">get_val</span>(a[p].l, rk);</span><br><span class="line">    <span class="keyword">if</span>(a[a[p].l].siz + a[p].cnt &gt;= rk) <span class="keyword">return</span> a[p].val;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_val</span>(a[p].r, rk - a[a[p].l].siz - a[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zig</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = a[p].l;</span><br><span class="line">    a[p].l = a[q].r, a[q].r = p;</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">upd</span>(a[p].r), <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zag</span><span class="params">(<span class="keyword">int</span> &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = a[p].r;</span><br><span class="line">    a[p].r = a[q].l, a[q].l = p;</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">upd</span>(a[p].l), <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) &#123;</span><br><span class="line">        p = <span class="built_in">New</span>(val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) &#123;</span><br><span class="line">        ++a[p].cnt, <span class="built_in">upd</span>(p);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; a[p].val) &#123;</span><br><span class="line">        <span class="built_in">ins</span>(a[p].l, val);</span><br><span class="line">        <span class="keyword">if</span>(a[p].dat &lt; a[a[p].l].dat) <span class="built_in">zig</span>(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ins</span>(a[p].r, val);</span><br><span class="line">        <span class="keyword">if</span>(a[p].dat &lt; a[a[p].r].dat) <span class="built_in">zag</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nxt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> p = rt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p].val == val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p].r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p = a[p].r;</span><br><span class="line">                <span class="keyword">while</span>(a[p].l &gt; <span class="number">0</span>) p = a[p].l;</span><br><span class="line">                ans = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p;</span><br><span class="line">        p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = rt;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val == a[p].val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p].l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p = a[p].l;</span><br><span class="line">                <span class="keyword">while</span>(a[p].r &gt; <span class="number">0</span>) p = a[p].r;</span><br><span class="line">                ans = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p;</span><br><span class="line">        p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[ans].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            --a[p].cnt, <span class="built_in">upd</span>(p);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[p].l || a[p].r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p].r == <span class="number">0</span> || a[a[p].l].dat &gt; a[a[p].r].dat) <span class="built_in">zig</span>(p), <span class="built_in">del</span>(a[p].r, val);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">zag</span>(p), <span class="built_in">del</span>(a[p].l, val);</span><br><span class="line">            <span class="built_in">upd</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    val &lt; a[p].val ? <span class="built_in">del</span>(a[p].l, val) : <span class="built_in">del</span>(a[p].r, val);</span><br><span class="line">    <span class="built_in">upd</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="keyword">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">New</span>(-INF);</span><br><span class="line">    <span class="built_in">New</span>(INF);</span><br><span class="line">    rt = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">upd</span>(rt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">rd</span>(), x = <span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) <span class="built_in">ins</span>(rt, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>) <span class="built_in">del</span>(rt, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_rk</span>(rt, x) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_val</span>(rt, x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_pre</span>(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">get_nxt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Splay</title>
    <link href="/2022/08/25/Splay/"/>
    <url>/2022/08/25/Splay/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>中午写的博文，脑子不大清醒，代码直接重写的没有从写好的粘贴，如果哪里写挂了就按照代码逻辑看下去吧（反正评论区现在不大正常），实在弄不懂了可以去洛谷私信。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>我们之前弄了 Treap 的平衡树，顺手我们把 Splay 的也弄了吧。</p><p>Treap 通过随机值和堆性质使得 BST 保持平衡，而 Splay 的操作则是不断将某个节点旋转到根节点，使得整棵树仍然满足 BST  的性质并且保持平衡。</p><p>我们约定几个定义：</p><ol><li>$rt$：根节点的编号</li><li>$tot$：节点个数</li><li>$fa_i$：表示 $i$ 的父亲</li><li>$ch_{i, 0/1}$：表示左右儿子编号</li><li>$val_i$：表示节点权值</li><li>$cnt_i$：表示权值出现次数</li><li>$siz_i$：表示子树大小</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p>upd(x)：在改变节点位置后，将节点 $x$ 的 $siz$ 更新</p><p>get(x)：判断 $x$ 是父亲节点的左儿子还是右儿子</p><p>clear(x)：移除节点 $x$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;siz[x] = siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + cnt[x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = fa[x] = val[x] = siz[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>旋转的本质其实就是将某个节点上移一个位置。</p><p>Splay 中的旋转分为左旋和右旋。</p><p>下边建议找图看，你懂的，我不想弄图这种东西。</p><p>我们假设需要旋转的节点为 $x$，它的父亲是 $y$，依旧以右旋为例。</p><ol><li>将 $y$ 的左儿子指向 $x$ 的右儿子，且 $x$ 的右儿子（如果有的话）的父亲指向 $y$。</li><li>将 $x$ 的右儿子指向 $y$，$y$ 的父亲指向 $x$。</li><li>如果原来 $y$ 还有父亲 $z$，那么把 $z$ 原来 $y$ 所在的儿子位置指向 $x$，$x$ 的父亲指向 $z$。</li></ol><p>其实 Splay 里边不需要写一个左旋再写一个右旋，我们一个旋转函数就好了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rorate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = fa[x], z = fa[y], chk = <span class="built_in">get</span>(x);</span><br><span class="line">    ch[y][chk] = ch[x][chk ^ <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(ch[x][chk ^ <span class="number">1</span>]) fa[ch[x][chk ^ <span class="number">1</span>]] = y;</span><br><span class="line">    ch[x][chk ^ <span class="number">1</span>] = y;</span><br><span class="line">    fa[y] = x;</span><br><span class="line">    fa[x] = z;</span><br><span class="line">    <span class="keyword">if</span>(z) ch[z][y == ch[z][<span class="number">1</span>]] = x;</span><br><span class="line">    <span class="built_in">upd</span>(y);</span><br><span class="line">    <span class="built_in">upd</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h3><p>这个操作规定每访问一个节点后都要强制将其转到根节点，此时旋转操作分为六种情况，用三种操作处理（可以去 OI Wiki 上看图，这里我依旧不给了）：</p><ol><li>如果 $x$ 的父亲是根节点，直接转。</li><li>如果 $x$ 的父亲不是根节点并且 $x$ 和父亲的儿子类型相同，首先我们把父亲旋转，然后再旋转 $x$。</li><li>如果 $x$ 的父亲不是根节点并且 $x$ 和父亲的儿子类型不同，对 $x$ 左旋再右旋，或者是右旋再左旋。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> f = fa[x]; f = fa[x], f; <span class="built_in">rorate</span>(x))</span><br><span class="line">        <span class="keyword">if</span>(fa[f]) <span class="built_in">rorate</span>(<span class="built_in">get</span>(x) == <span class="built_in">get</span>(f) ? f : x);</span><br><span class="line">    </span><br><span class="line">    rt = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>我们设插入值为 $val$。</p><p>如果树空了，直接插入根并退出。</p><p>如果当前节点的权值等于 $val$ 则增加当前节点的大小并更新节点和父亲的信息，然后 splay。</p><p>否则，按照 BST 性质向下找，找到空节点插入即可，注意 splay。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) &#123;</span><br><span class="line">        val[++tot] = v;</span><br><span class="line">        ++cnt[tot];</span><br><span class="line">        rt = tot;</span><br><span class="line">        <span class="built_in">upd</span>(rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u = rt, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val[u] == v) &#123;</span><br><span class="line">            ++cnt[u];</span><br><span class="line">            <span class="built_in">upd</span>(u); <span class="comment">// 先更新儿子再更新父亲</span></span><br><span class="line">            <span class="built_in">upd</span>(f);</span><br><span class="line">            <span class="built_in">splay</span>(u);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = u;</span><br><span class="line">        u = ch[u][val[u] &lt; v];</span><br><span class="line">        <span class="keyword">if</span>(!u) &#123; <span class="comment">// 找到了一个空节点</span></span><br><span class="line">            val[++tot] = v;</span><br><span class="line">            ++cnt[tot];</span><br><span class="line">            fa[tot] = f;</span><br><span class="line">            ch[f][val[f] &lt; v] = tot; <span class="comment">// 看看放到哪个子树合适</span></span><br><span class="line">            <span class="built_in">upd</span>(tot);</span><br><span class="line">            <span class="built_in">upd</span>(f);</span><br><span class="line">            <span class="built_in">splay</span>(tot);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询-x-的排名"><a href="#查询-x-的排名" class="headerlink" title="查询 $x$ 的排名"></a>查询 $x$ 的排名</h3><p>如果 $x$ 比当前节点权值小，去左子树找。</p><p>如果比当前节点权值大，那么我们把答案加上左子树和当前节点的大小，向右子树找。</p><p>如果相等，将答案加上 1 返回。</p><p>最后还要 splay。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_rk</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, u = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(v &lt; val[u]) u = ch[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += siz[c[u][<span class="number">0</span>]];</span><br><span class="line">            <span class="keyword">if</span>(v == val[u]) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(u);</span><br><span class="line">                <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += cnt[u];</span><br><span class="line">            u = ch[u][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询排名为-k-的数"><a href="#查询排名为-k-的数" class="headerlink" title="查询排名为 $k$ 的数"></a>查询排名为 $k$ 的数</h3><p>设 $k$ 为剩余排名。</p><p>如果左子树非空并且 $k$ 不大于左子树大小，向左子树中查找。</p><p>否则，将 $k$ 减去左子树和根的大小，如果 $k$ 小于等于 0 说明这个点在根上，返回根节点的权值即可，否则继续向右子树查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[u][<span class="number">0</span>] &amp;&amp; k &lt;= siz[ch[u][<span class="number">0</span>]]) u = ch[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            k -= (cnt[u] + siz[ch[u][<span class="number">0</span>]]);</span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">splay</span>(u);</span><br><span class="line">                <span class="keyword">return</span> val[u];</span><br><span class="line">            &#125;</span><br><span class="line">            u = ch[u][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找前驱"><a href="#查找前驱" class="headerlink" title="查找前驱"></a>查找前驱</h2><p>查询 $v$ 的前驱可以转化为：将 $v$ 插入（因为 splay 操作，$v$ 已经在根的位置了），前驱为根的左子树中最大的节点，最后删除 $v$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = ch[rt][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(!u) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">while</span>(ch[u][<span class="number">1</span>]) u = ch[u][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并与删除"><a href="#合并与删除" class="headerlink" title="合并与删除"></a>合并与删除</h2><p>合并两颗 Splay 树，设两树根节点分别为 $x$ 和 $y$，我们要求 $x$ 树中的最大值小于 $y$ 树中的最小值。</p><p>如果 $x$ 和 $y$ 其中之一或者是两者都为空树，直接返回不为空的那一棵树的根节点或者是空树。</p><p>否则将 $x$ 树中的最大值 Splay 到根，然后把它的右子树设置为 $y$ 并更新节点的信息，然后返回这个节点。</p><p>删除 $x$，首先将 $x$ 转到根的位置，如果 $cnt_x &gt; 1$ ，直接将 $cnt_x$ 减 1 并退出。</p><p>否则，合并它的左右两棵子树即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rk</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(cnt[rt] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        --cnt[rt];</span><br><span class="line">        <span class="built_in">upd</span>(rt);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][<span class="number">0</span>] &amp;&amp; !ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="built_in">clear</span>(rt);</span><br><span class="line">        rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        rt = ch[rt][<span class="number">1</span>];</span><br><span class="line">        fa[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clear</span>(u);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        rt = ch[rt][<span class="number">0</span>];</span><br><span class="line">        fa[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">clear</span>(u);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u = rt, x = <span class="built_in">pre</span>();</span><br><span class="line">    fa[ch[u][<span class="number">1</span>]] = x;</span><br><span class="line">    ch[x][<span class="number">1</span>] = ch[u][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">clear</span>(u);</span><br><span class="line">    <span class="built_in">upd</span>(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们写数据结构要封装的良好习惯，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> siz[N];</span><br><span class="line">    <span class="keyword">int</span> tot, fa[N], ch[N][<span class="number">2</span>], val[N], cnt[N];</span><br><span class="line">    <span class="keyword">int</span> rt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; siz[x] = siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + cnt[x];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = fa[x] = val[x] = siz[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rorate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = fa[x], z = fa[y], chk = <span class="built_in">get</span>(x);</span><br><span class="line">        ch[y][chk] = ch[y][chk ^ <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ch[x][chk ^ <span class="number">1</span>]) fa[ch[x][chk ^ <span class="number">1</span>]] = y;</span><br><span class="line">        ch[x][chk ^ <span class="number">1</span>] = y;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        fa[x] = z;</span><br><span class="line">        <span class="keyword">if</span>(z) ch[z][y == ch[z][<span class="number">1</span>]] = x;</span><br><span class="line">        <span class="built_in">upd</span>(y), <span class="built_in">upd</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> f = fa[x]; f = fa[x], f; <span class="built_in">rorate</span>(x))</span><br><span class="line">            <span class="keyword">if</span>(fa[f]) <span class="built_in">rorate</span>(<span class="built_in">get</span>(x) == <span class="built_in">get</span>(f) ? f : x);</span><br><span class="line"></span><br><span class="line">        rt = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!rt) &#123;</span><br><span class="line">            val[++tot] = v;</span><br><span class="line">            ++cnt[tot];</span><br><span class="line">            rt = tot;</span><br><span class="line">            <span class="built_in">upd</span>(rt);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u = rt, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val[u] == v) &#123;</span><br><span class="line">                ++cnt[u];</span><br><span class="line">                <span class="built_in">upd</span>(u);</span><br><span class="line">                <span class="built_in">upd</span>(f);</span><br><span class="line">                <span class="built_in">splay</span>(u);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f = u;</span><br><span class="line">            u = ch[u][val[u] &lt; v];</span><br><span class="line">            <span class="keyword">if</span>(!u) &#123;</span><br><span class="line">                val[++tot] = v;</span><br><span class="line">                ++cnt[tot];</span><br><span class="line">                fa[tot] = f;</span><br><span class="line">                ch[f][val[f] &lt; v] = tot;</span><br><span class="line">                <span class="built_in">upd</span>(tot);</span><br><span class="line">                <span class="built_in">upd</span>(f);</span><br><span class="line">                <span class="built_in">splay</span>(tot);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_rk</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, u = rt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; val[u]) u = ch[u][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += siz[ch[u][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span>(v == val[u]) &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(u);</span><br><span class="line">                    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res += cnt[u];</span><br><span class="line">                u = ch[u][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_v</span><span class="params">(<span class="keyword">int</span> rk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[u][<span class="number">0</span>] &amp;&amp; rk &lt;= siz[ch[u][<span class="number">0</span>]]) u = ch[u][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                rk -= cnt[u] + siz[ch[u][<span class="number">0</span>]];</span><br><span class="line">                <span class="keyword">if</span>(rk &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">splay</span>(rk);</span><br><span class="line">                    <span class="keyword">return</span> val[u];</span><br><span class="line">                &#125;</span><br><span class="line">                u = ch[u][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = ch[rt][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(!u) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">while</span>(ch[u][<span class="number">1</span>]) u = ch[u][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_nxt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = ch[rt][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!u) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">while</span>(ch[u][<span class="number">0</span>]) u = ch[u][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">splay</span>(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">get_rk</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(cnt[rt] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            --cnt[rt];</span><br><span class="line">            <span class="built_in">upd</span>(rt);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ch[rt][<span class="number">0</span>] &amp;&amp; !ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">clear</span>(rt);</span><br><span class="line">            rt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ch[rt][<span class="number">0</span>] &amp;&amp; !ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="built_in">clear</span>(rt);</span><br><span class="line">            rt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ch[rt][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = rt;</span><br><span class="line">            rt = ch[rt][<span class="number">1</span>];</span><br><span class="line">            fa[rt] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clear</span>(u);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ch[rt][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = rt;</span><br><span class="line">            rt = ch[rt][<span class="number">0</span>];</span><br><span class="line">            fa[rt] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">clear</span>(u);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> u = rt;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">get_pre</span>();</span><br><span class="line">        fa[ch[u][<span class="number">1</span>]] = x;</span><br><span class="line">        ch[x][<span class="number">1</span>] = ch[u][<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">clear</span>(u);</span><br><span class="line">        <span class="built_in">upd</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;spl;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BST</title>
    <link href="/2022/08/24/BST/"/>
    <url>/2022/08/24/BST/</url>
    
    <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>BST 是二叉搜索树的简称，我们定义 BST 上每一个节点都有一个<strong>关键值</strong>，（就是点权好吧）。</p><p>BST 上每一个节点都满足以下性质：</p><ol><li>该节点所有左子树的关键值都小于等于该节点的关键值。</li><li>该节点所有右子树的关键值都大于等于该节点的关键值。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>出于避免越界，减少特殊判断的目的，我们一般会往 BST 里边丢一个负无穷的关键值和一个正无穷的关键值，仅有这两个节点组成的 BST 就是一颗空的 BST。</p><p>接下来我们假设 BST 里不会出现关键值相同的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bst</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r; <span class="comment">// 左子树右子树的下标</span></span><br><span class="line">    <span class="keyword">int</span> val; <span class="comment">// 关键值</span></span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">New</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    a[++tot].val = val; <span class="comment">// 把一个关键值插入</span></span><br><span class="line">    <span class="keyword">return</span> tot; <span class="comment">// 返回节点编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">New</span>(-INF); <span class="comment">// 先插入负无穷</span></span><br><span class="line">    <span class="built_in">New</span>(INF); <span class="comment">// 再插入正无穷当负无穷的右子树</span></span><br><span class="line">    rt = <span class="number">1</span>, a[<span class="number">1</span>].r = <span class="number">2</span>; <span class="comment">// 根弄成 1，1 的后继下标当然是 2 咯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>在 BST 中查找是否存在关键值为 $\operatorname{val}$ 的节点。</p><p>设变量 $p$ 等于根节点，执行：</p><ol><li>如果 $p$ 的关键值等于 $val$，已经找到了。</li><li>如果 $p$ 的关键值小于 $val$，如果 $p$ 的右子树为空说明不存在 $val$，否则就进去找 $val$。</li><li>如果 $p$ 的关键值大于 $val$，如果 $p$ 的左子树为空说明不存在 $val$，否则就进去找 $val$。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 都找不到了直接返回呗</span></span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) <span class="keyword">return</span> p; <span class="comment">// 找到了就直接返回呗</span></span><br><span class="line">    <span class="keyword">return</span> val &lt; a[p].val ? <span class="built_in">get</span>(a[p].l, val) : <span class="built_in">get</span>(a[p].r, val); <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>在 BST 中插入一个新值，和查找类似。找到要走向的 $p$ 的子节点为空，说明 $val$ 不存在，直接建立关键值为 $val$ 的新节点作为 $p$ 的子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) &#123;</span><br><span class="line">        p = <span class="built_in">New</span>(val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; a[p].val) <span class="built_in">ins</span>(a[p].l, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求前驱后继"><a href="#求前驱后继" class="headerlink" title="求前驱后继"></a>求前驱后继</h2><p>先谈谈后继吧：</p><p>后继是指在 BST 中关键值大于 $val$ 的前提下，关键值最小的节点。</p><p>我们定义这个节点的编号为 $ans$，跑去查找 $val$，会有以下结果：</p><ol><li>没有找到 $val$，这就说明 $val$  的后继已经在经过的节点中更新过了，$ans$ 即为所求。</li><li>找到了 $val$ 的节点 $p$，如果 $p$ 没有右子树，说明你已经找到了，$ans$ 即为所求。</li><li>好吧 $p$ 它有右子树，没关系，我们进入右子树，然后向左子树跑，去找一个最贴近 $val$ 的值，然后这个 $val$ 对应的 $p$ 就是后继所在的节点。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnxt</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>; <span class="comment">// 我觉得吧，答案节点要从 2 开始防止判断边</span></span><br><span class="line">    <span class="keyword">int</span> p = rt; <span class="comment">// 从根开始找</span></span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val == a[p].val) &#123; <span class="comment">// 如果找到了 val</span></span><br><span class="line">            <span class="keyword">if</span>(a[p].r &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果还有右子树</span></span><br><span class="line">                p = a[p].r; <span class="comment">// 进入它的右子树，然后往左边跑去找更合适</span></span><br><span class="line">                <span class="keyword">while</span>(a[p].l &gt; <span class="number">0</span>) p = a[p].l; <span class="comment">// 往左边跑</span></span><br><span class="line">                ans = p; <span class="comment">// 更新下 ans</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[p].val &gt; val &amp;&amp; a[p].val &lt; a[ans].val) ans = p; <span class="comment">// 沿途尝试更新 ans</span></span><br><span class="line">        p = val &lt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找前驱同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpre</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = rt;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(val == a[p].val) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[p].l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p = a[p].l;</span><br><span class="line">                <span class="keyword">while</span>(a[p].r &gt; <span class="number">0</span>) p = a[p].r;</span><br><span class="line">                ans = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[p].val &lt; val &amp;&amp; a[p].val &gt; a[ans].val) ans = p;</span><br><span class="line">        p = val &gt; a[p].val ? a[p].l : a[p].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除关键值为 $val$ 的节点 $p$。还是先跑去查找 $val$，得到节点 $p$，如果 $p$ 的子节点个数小于 2，直接把 $p$ 删掉，然后把 $p$ 的子节点接到 $p$ 的位置就可以了。</p><p>好吧，$p$ 既有左子树又有右子树，我们直接去找出 $val$ 的后继节点 $nxt$，因为 $nxt$ 是没有左子树的（不然要你当什么后继？），直接把 $nxt$ 删掉，然后让 $nxt$ 的右子树顶到 $nxt$ 的位置，最后把 $nxt$ 丢到 $p$ 的位置上，然后删除 $p$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;p, <span class="keyword">int</span> val)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(val == a[p].val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[p].l == <span class="number">0</span>) p = a[p].r; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[p].r == <span class="number">0</span>) p = a[p].l;  </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt = a[p].r;</span><br><span class="line">            <span class="keyword">while</span>(a[nxt].l &gt; <span class="number">0</span>) nxt = a[nxt].l;</span><br><span class="line">            <span class="built_in">del</span>(a[p].r, a[nxt].val);</span><br><span class="line">            a[nxt].l = a[p].l, a[nxt].r = a[p].r;</span><br><span class="line">            p = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; a[p].val) <span class="built_in">del</span>(a[p].l, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">del</span>(a[p].r, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BST 的期望时间复杂度是 $\mathcal{O}(\log n)$ 的，坑人的是，BST 很容易退化，出题人随手扔给你一个有序的序列，BST 直接变成了 $\mathcal{O}(n)$。然后我们就只能在聊天框里发个 gg 了<del>这样还能在 Hypixel 服务器里加上 5rp 值</del>。</p><p>我们称这种左右子树差很大的 BST 是不平衡的，我们可以用一些奇妙的方法把它弄得平衡，怎么弄平衡呢？<del>看下一篇博文吧。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>Data Structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
